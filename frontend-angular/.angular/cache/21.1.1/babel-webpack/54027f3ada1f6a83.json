{"ast":null,"code":"/**\n * @license Angular v21.1.1\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed } from './_effect-chunk.mjs';\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n  const node = Object.create(LINKED_SIGNAL_NODE);\n  node.source = sourceFn;\n  node.computation = computationFn;\n  if (equalityFn != undefined) {\n    node.equal = equalityFn;\n  }\n  const linkedSignalGetter = () => {\n    producerUpdateValueVersion(node);\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  const getter = linkedSignalGetter;\n  getter[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[LinkedSignal${debugName}: ${String(node.value)}]`;\n  }\n  runPostProducerCreatedFn(node);\n  return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n  producerUpdateValueVersion(node);\n  signalSetFn(node, newValue);\n  producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n  producerUpdateValueVersion(node);\n  signalUpdateFn(node, updater);\n  producerMarkClean(node);\n}\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'linkedSignal',\n    producerMustRecompute(node) {\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      try {\n        const newSourceValue = node.source();\n        const prev = oldValue === UNSET || oldValue === ERRORED ? undefined : {\n          source: node.sourceValue,\n          value: oldValue\n        };\n        newValue = node.computation(newSourceValue, prev);\n        node.sourceValue = newSourceValue;\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn };","map":{"version":3,"names":["SIGNAL","runPostProducerCreatedFn","producerUpdateValueVersion","signalSetFn","producerMarkClean","signalUpdateFn","REACTIVE_NODE","UNSET","defaultEquals","COMPUTING","consumerBeforeComputation","ERRORED","consumerAfterComputation","producerAccessed","createLinkedSignal","sourceFn","computationFn","equalityFn","node","Object","create","LINKED_SIGNAL_NODE","source","computation","undefined","equal","linkedSignalGetter","value","error","getter","ngDevMode","debugName","toString","String","linkedSignalSetFn","newValue","linkedSignalUpdateFn","updater","dirty","kind","producerMustRecompute","producerRecomputeValue","Error","oldValue","prevConsumer","newSourceValue","prev","sourceValue","err","version"],"sources":["/home/dfirth2/fiber_route_calculator/frontend-angular/node_modules/@angular/core/fesm2022/_linked_signal-chunk.mjs"],"sourcesContent":["/**\n * @license Angular v21.1.1\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed } from './_effect-chunk.mjs';\n\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n  const node = Object.create(LINKED_SIGNAL_NODE);\n  node.source = sourceFn;\n  node.computation = computationFn;\n  if (equalityFn != undefined) {\n    node.equal = equalityFn;\n  }\n  const linkedSignalGetter = () => {\n    producerUpdateValueVersion(node);\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  const getter = linkedSignalGetter;\n  getter[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[LinkedSignal${debugName}: ${String(node.value)}]`;\n  }\n  runPostProducerCreatedFn(node);\n  return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n  producerUpdateValueVersion(node);\n  signalSetFn(node, newValue);\n  producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n  producerUpdateValueVersion(node);\n  signalUpdateFn(node, updater);\n  producerMarkClean(node);\n}\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'linkedSignal',\n    producerMustRecompute(node) {\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      try {\n        const newSourceValue = node.source();\n        const prev = oldValue === UNSET || oldValue === ERRORED ? undefined : {\n          source: node.sourceValue,\n          value: oldValue\n        };\n        newValue = node.computation(newSourceValue, prev);\n        node.sourceValue = newSourceValue;\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\n\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}