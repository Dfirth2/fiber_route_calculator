{"ast":null,"code":"/**\n * @license Angular v21.1.1\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\nimport { validateStyleProperty, containsElement, getParentElement, invokeQuery, dashCaseToCamelCase, invalidCssUnitValue, invalidExpression, invalidTransitionAlias, visitDslNode, invalidTrigger, invalidDefinition, extractStyleParams, invalidState, invalidStyleValue, SUBSTITUTION_EXPR_START, invalidParallelAnimation, validateStyleParams, invalidKeyframes, invalidOffset, keyframeOffsetsOutOfOrder, keyframesMissingOffsets, getOrSetDefaultValue, invalidStagger, resolveTiming, NG_TRIGGER_SELECTOR, NG_ANIMATING_SELECTOR, normalizeAnimationEntry, resolveTimingValue, interpolateParams, invalidQuery, registerFailed, normalizeKeyframes, LEAVE_CLASSNAME, ENTER_CLASSNAME, missingOrDestroyedAnimation, createAnimationFailed, optimizeGroupPlayer, missingPlayer, listenOnPlayer, makeAnimationEvent, triggerTransitionsFailed, eraseStyles, setStyles, transitionFailed, missingTrigger, missingEvent, unsupportedTriggerEvent, NG_TRIGGER_CLASSNAME, unregisteredTrigger, NG_ANIMATING_CLASSNAME, triggerBuildFailed, parseTimelineCommand, computeStyle, camelCaseToDashCase, validateWebAnimatableStyleProperty, allowPreviousPlayerStylesMerge, normalizeKeyframes$1, balancePreviousStylesIntoKeyframes, validationFailed, normalizeStyles, buildingFailed } from './_util-chunk.mjs';\nimport { NoopAnimationPlayer, AnimationMetadataType, style, AUTO_STYLE, ɵPRE_STYLE as _PRE_STYLE, AnimationGroupPlayer } from './_private_export-chunk.mjs';\nclass NoopAnimationDriver {\n  validateStyleProperty(prop) {\n    return validateStyleProperty(prop);\n  }\n  containsElement(elm1, elm2) {\n    return containsElement(elm1, elm2);\n  }\n  getParentElement(element) {\n    return getParentElement(element);\n  }\n  query(element, selector, multi) {\n    return invokeQuery(element, selector, multi);\n  }\n  computeStyle(element, prop, defaultValue) {\n    return defaultValue || '';\n  }\n  animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {\n    return new NoopAnimationPlayer(duration, delay);\n  }\n  static ɵfac = function NoopAnimationDriver_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NoopAnimationDriver)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NoopAnimationDriver,\n    factory: NoopAnimationDriver.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NoopAnimationDriver, [{\n    type: Injectable\n  }], null, null);\n})();\nclass AnimationDriver {\n  static NOOP = new NoopAnimationDriver();\n}\nclass AnimationStyleNormalizer {}\nclass NoopAnimationStyleNormalizer {\n  normalizePropertyName(propertyName, errors) {\n    return propertyName;\n  }\n  normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {\n    return value;\n  }\n}\nconst DIMENSIONAL_PROP_SET = new Set(['width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight', 'left', 'top', 'bottom', 'right', 'fontSize', 'outlineWidth', 'outlineOffset', 'paddingTop', 'paddingLeft', 'paddingBottom', 'paddingRight', 'marginTop', 'marginLeft', 'marginBottom', 'marginRight', 'borderRadius', 'borderWidth', 'borderTopWidth', 'borderLeftWidth', 'borderRightWidth', 'borderBottomWidth', 'textIndent', 'perspective']);\nclass WebAnimationsStyleNormalizer extends AnimationStyleNormalizer {\n  normalizePropertyName(propertyName, errors) {\n    return dashCaseToCamelCase(propertyName);\n  }\n  normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {\n    let unit = '';\n    const strVal = value.toString().trim();\n    if (DIMENSIONAL_PROP_SET.has(normalizedProperty) && value !== 0 && value !== '0') {\n      if (typeof value === 'number') {\n        unit = 'px';\n      } else {\n        const valAndSuffixMatch = value.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n          errors.push(invalidCssUnitValue(userProvidedProperty, value));\n        }\n      }\n    }\n    return strVal + unit;\n  }\n}\nfunction createListOfWarnings(warnings) {\n  const LINE_START = '\\n - ';\n  return `${LINE_START}${warnings.filter(Boolean).map(warning => warning).join(LINE_START)}`;\n}\nfunction warnValidation(warnings) {\n  console.warn(`animation validation warnings:${createListOfWarnings(warnings)}`);\n}\nfunction warnTriggerBuild(name, warnings) {\n  console.warn(`The animation trigger \"${name}\" has built with the following warnings:${createListOfWarnings(warnings)}`);\n}\nfunction warnRegister(warnings) {\n  console.warn(`Animation built with the following warnings:${createListOfWarnings(warnings)}`);\n}\nfunction pushUnrecognizedPropertiesWarning(warnings, props) {\n  if (props.length) {\n    warnings.push(`The following provided properties are not recognized: ${props.join(', ')}`);\n  }\n}\nconst ANY_STATE = '*';\nfunction parseTransitionExpr(transitionValue, errors) {\n  const expressions = [];\n  if (typeof transitionValue == 'string') {\n    transitionValue.split(/\\s*,\\s*/).forEach(str => parseInnerTransitionStr(str, expressions, errors));\n  } else {\n    expressions.push(transitionValue);\n  }\n  return expressions;\n}\nfunction parseInnerTransitionStr(eventStr, expressions, errors) {\n  if (eventStr[0] == ':') {\n    const result = parseAnimationAlias(eventStr, errors);\n    if (typeof result == 'function') {\n      expressions.push(result);\n      return;\n    }\n    eventStr = result;\n  }\n  const match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n  if (match == null || match.length < 4) {\n    errors.push(invalidExpression(eventStr));\n    return expressions;\n  }\n  const fromState = match[1];\n  const separator = match[2];\n  const toState = match[3];\n  expressions.push(makeLambdaFromStates(fromState, toState));\n  const isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n  if (separator[0] == '<' && !isFullAnyStateExpr) {\n    expressions.push(makeLambdaFromStates(toState, fromState));\n  }\n  return;\n}\nfunction parseAnimationAlias(alias, errors) {\n  switch (alias) {\n    case ':enter':\n      return 'void => *';\n    case ':leave':\n      return '* => void';\n    case ':increment':\n      return (fromState, toState) => parseFloat(toState) > parseFloat(fromState);\n    case ':decrement':\n      return (fromState, toState) => parseFloat(toState) < parseFloat(fromState);\n    default:\n      errors.push(invalidTransitionAlias(alias));\n      return '* => *';\n  }\n}\nconst TRUE_BOOLEAN_VALUES = new Set(['true', '1']);\nconst FALSE_BOOLEAN_VALUES = new Set(['false', '0']);\nfunction makeLambdaFromStates(lhs, rhs) {\n  const LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);\n  const RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);\n  return (fromState, toState) => {\n    let lhsMatch = lhs == ANY_STATE || lhs == fromState;\n    let rhsMatch = rhs == ANY_STATE || rhs == toState;\n    if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === 'boolean') {\n      lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);\n    }\n    if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === 'boolean') {\n      rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);\n    }\n    return lhsMatch && rhsMatch;\n  };\n}\nconst SELF_TOKEN = ':self';\nconst SELF_TOKEN_REGEX = /* @__PURE__ */new RegExp(`s*${SELF_TOKEN}s*,?`, 'g');\nfunction buildAnimationAst(driver, metadata, errors, warnings) {\n  return new AnimationAstBuilderVisitor(driver).build(metadata, errors, warnings);\n}\nconst ROOT_SELECTOR = '';\nclass AnimationAstBuilderVisitor {\n  _driver;\n  constructor(_driver) {\n    this._driver = _driver;\n  }\n  build(metadata, errors, warnings) {\n    const context = new AnimationAstBuilderContext(errors);\n    this._resetContextStyleTimingState(context);\n    const ast = visitDslNode(this, normalizeAnimationEntry(metadata), context);\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (context.unsupportedCSSPropertiesFound.size) {\n        pushUnrecognizedPropertiesWarning(warnings, [...context.unsupportedCSSPropertiesFound.keys()]);\n      }\n    }\n    return ast;\n  }\n  _resetContextStyleTimingState(context) {\n    context.currentQuerySelector = ROOT_SELECTOR;\n    context.collectedStyles = new Map();\n    context.collectedStyles.set(ROOT_SELECTOR, new Map());\n    context.currentTime = 0;\n  }\n  visitTrigger(metadata, context) {\n    let queryCount = context.queryCount = 0;\n    let depCount = context.depCount = 0;\n    const states = [];\n    const transitions = [];\n    if (metadata.name.charAt(0) == '@') {\n      context.errors.push(invalidTrigger());\n    }\n    metadata.definitions.forEach(def => {\n      this._resetContextStyleTimingState(context);\n      if (def.type == AnimationMetadataType.State) {\n        const stateDef = def;\n        const name = stateDef.name;\n        name.toString().split(/\\s*,\\s*/).forEach(n => {\n          stateDef.name = n;\n          states.push(this.visitState(stateDef, context));\n        });\n        stateDef.name = name;\n      } else if (def.type == AnimationMetadataType.Transition) {\n        const transition = this.visitTransition(def, context);\n        queryCount += transition.queryCount;\n        depCount += transition.depCount;\n        transitions.push(transition);\n      } else {\n        context.errors.push(invalidDefinition());\n      }\n    });\n    return {\n      type: AnimationMetadataType.Trigger,\n      name: metadata.name,\n      states,\n      transitions,\n      queryCount,\n      depCount,\n      options: null\n    };\n  }\n  visitState(metadata, context) {\n    const styleAst = this.visitStyle(metadata.styles, context);\n    const astParams = metadata.options && metadata.options.params || null;\n    if (styleAst.containsDynamicStyles) {\n      const missingSubs = new Set();\n      const params = astParams || {};\n      styleAst.styles.forEach(style => {\n        if (style instanceof Map) {\n          style.forEach(value => {\n            extractStyleParams(value).forEach(sub => {\n              if (!params.hasOwnProperty(sub)) {\n                missingSubs.add(sub);\n              }\n            });\n          });\n        }\n      });\n      if (missingSubs.size) {\n        context.errors.push(invalidState(metadata.name, [...missingSubs.values()]));\n      }\n    }\n    return {\n      type: AnimationMetadataType.State,\n      name: metadata.name,\n      style: styleAst,\n      options: astParams ? {\n        params: astParams\n      } : null\n    };\n  }\n  visitTransition(metadata, context) {\n    context.queryCount = 0;\n    context.depCount = 0;\n    const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);\n    const matchers = parseTransitionExpr(metadata.expr, context.errors);\n    return {\n      type: AnimationMetadataType.Transition,\n      matchers,\n      animation,\n      queryCount: context.queryCount,\n      depCount: context.depCount,\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitSequence(metadata, context) {\n    return {\n      type: AnimationMetadataType.Sequence,\n      steps: metadata.steps.map(s => visitDslNode(this, s, context)),\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitGroup(metadata, context) {\n    const currentTime = context.currentTime;\n    let furthestTime = 0;\n    const steps = metadata.steps.map(step => {\n      context.currentTime = currentTime;\n      const innerAst = visitDslNode(this, step, context);\n      furthestTime = Math.max(furthestTime, context.currentTime);\n      return innerAst;\n    });\n    context.currentTime = furthestTime;\n    return {\n      type: AnimationMetadataType.Group,\n      steps,\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitAnimate(metadata, context) {\n    const timingAst = constructTimingAst(metadata.timings, context.errors);\n    context.currentAnimateTimings = timingAst;\n    let styleAst;\n    let styleMetadata = metadata.styles ? metadata.styles : style({});\n    if (styleMetadata.type == AnimationMetadataType.Keyframes) {\n      styleAst = this.visitKeyframes(styleMetadata, context);\n    } else {\n      let styleMetadata = metadata.styles;\n      let isEmpty = false;\n      if (!styleMetadata) {\n        isEmpty = true;\n        const newStyleData = {};\n        if (timingAst.easing) {\n          newStyleData['easing'] = timingAst.easing;\n        }\n        styleMetadata = style(newStyleData);\n      }\n      context.currentTime += timingAst.duration + timingAst.delay;\n      const _styleAst = this.visitStyle(styleMetadata, context);\n      _styleAst.isEmptyStep = isEmpty;\n      styleAst = _styleAst;\n    }\n    context.currentAnimateTimings = null;\n    return {\n      type: AnimationMetadataType.Animate,\n      timings: timingAst,\n      style: styleAst,\n      options: null\n    };\n  }\n  visitStyle(metadata, context) {\n    const ast = this._makeStyleAst(metadata, context);\n    this._validateStyleAst(ast, context);\n    return ast;\n  }\n  _makeStyleAst(metadata, context) {\n    const styles = [];\n    const metadataStyles = Array.isArray(metadata.styles) ? metadata.styles : [metadata.styles];\n    for (let styleTuple of metadataStyles) {\n      if (typeof styleTuple === 'string') {\n        if (styleTuple === AUTO_STYLE) {\n          styles.push(styleTuple);\n        } else {\n          context.errors.push(invalidStyleValue(styleTuple));\n        }\n      } else {\n        styles.push(new Map(Object.entries(styleTuple)));\n      }\n    }\n    let containsDynamicStyles = false;\n    let collectedEasing = null;\n    styles.forEach(styleData => {\n      if (styleData instanceof Map) {\n        if (styleData.has('easing')) {\n          collectedEasing = styleData.get('easing');\n          styleData.delete('easing');\n        }\n        if (!containsDynamicStyles) {\n          for (let value of styleData.values()) {\n            if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {\n              containsDynamicStyles = true;\n              break;\n            }\n          }\n        }\n      }\n    });\n    return {\n      type: AnimationMetadataType.Style,\n      styles,\n      easing: collectedEasing,\n      offset: metadata.offset,\n      containsDynamicStyles,\n      options: null\n    };\n  }\n  _validateStyleAst(ast, context) {\n    const timings = context.currentAnimateTimings;\n    let endTime = context.currentTime;\n    let startTime = context.currentTime;\n    if (timings && startTime > 0) {\n      startTime -= timings.duration + timings.delay;\n    }\n    ast.styles.forEach(tuple => {\n      if (typeof tuple === 'string') return;\n      tuple.forEach((value, prop) => {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._driver.validateStyleProperty(prop)) {\n            tuple.delete(prop);\n            context.unsupportedCSSPropertiesFound.add(prop);\n            return;\n          }\n        }\n        const collectedStyles = context.collectedStyles.get(context.currentQuerySelector);\n        const collectedEntry = collectedStyles.get(prop);\n        let updateCollectedStyle = true;\n        if (collectedEntry) {\n          if (startTime != endTime && startTime >= collectedEntry.startTime && endTime <= collectedEntry.endTime) {\n            context.errors.push(invalidParallelAnimation(prop, collectedEntry.startTime, collectedEntry.endTime, startTime, endTime));\n            updateCollectedStyle = false;\n          }\n          startTime = collectedEntry.startTime;\n        }\n        if (updateCollectedStyle) {\n          collectedStyles.set(prop, {\n            startTime,\n            endTime\n          });\n        }\n        if (context.options) {\n          validateStyleParams(value, context.options, context.errors);\n        }\n      });\n    });\n  }\n  visitKeyframes(metadata, context) {\n    const ast = {\n      type: AnimationMetadataType.Keyframes,\n      styles: [],\n      options: null\n    };\n    if (!context.currentAnimateTimings) {\n      context.errors.push(invalidKeyframes());\n      return ast;\n    }\n    const MAX_KEYFRAME_OFFSET = 1;\n    let totalKeyframesWithOffsets = 0;\n    const offsets = [];\n    let offsetsOutOfOrder = false;\n    let keyframesOutOfRange = false;\n    let previousOffset = 0;\n    const keyframes = metadata.steps.map(styles => {\n      const style = this._makeStyleAst(styles, context);\n      let offsetVal = style.offset != null ? style.offset : consumeOffset(style.styles);\n      let offset = 0;\n      if (offsetVal != null) {\n        totalKeyframesWithOffsets++;\n        offset = style.offset = offsetVal;\n      }\n      keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;\n      offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;\n      previousOffset = offset;\n      offsets.push(offset);\n      return style;\n    });\n    if (keyframesOutOfRange) {\n      context.errors.push(invalidOffset());\n    }\n    if (offsetsOutOfOrder) {\n      context.errors.push(keyframeOffsetsOutOfOrder());\n    }\n    const length = metadata.steps.length;\n    let generatedOffset = 0;\n    if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {\n      context.errors.push(keyframesMissingOffsets());\n    } else if (totalKeyframesWithOffsets == 0) {\n      generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);\n    }\n    const limit = length - 1;\n    const currentTime = context.currentTime;\n    const currentAnimateTimings = context.currentAnimateTimings;\n    const animateDuration = currentAnimateTimings.duration;\n    keyframes.forEach((kf, i) => {\n      const offset = generatedOffset > 0 ? i == limit ? 1 : generatedOffset * i : offsets[i];\n      const durationUpToThisFrame = offset * animateDuration;\n      context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;\n      currentAnimateTimings.duration = durationUpToThisFrame;\n      this._validateStyleAst(kf, context);\n      kf.offset = offset;\n      ast.styles.push(kf);\n    });\n    return ast;\n  }\n  visitReference(metadata, context) {\n    return {\n      type: AnimationMetadataType.Reference,\n      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitAnimateChild(metadata, context) {\n    context.depCount++;\n    return {\n      type: AnimationMetadataType.AnimateChild,\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitAnimateRef(metadata, context) {\n    return {\n      type: AnimationMetadataType.AnimateRef,\n      animation: this.visitReference(metadata.animation, context),\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitQuery(metadata, context) {\n    const parentSelector = context.currentQuerySelector;\n    const options = metadata.options || {};\n    context.queryCount++;\n    context.currentQuery = metadata;\n    const [selector, includeSelf] = normalizeSelector(metadata.selector);\n    context.currentQuerySelector = parentSelector.length ? parentSelector + ' ' + selector : selector;\n    getOrSetDefaultValue(context.collectedStyles, context.currentQuerySelector, new Map());\n    const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);\n    context.currentQuery = null;\n    context.currentQuerySelector = parentSelector;\n    return {\n      type: AnimationMetadataType.Query,\n      selector,\n      limit: options.limit || 0,\n      optional: !!options.optional,\n      includeSelf,\n      animation,\n      originalSelector: metadata.selector,\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitStagger(metadata, context) {\n    if (!context.currentQuery) {\n      context.errors.push(invalidStagger());\n    }\n    const timings = metadata.timings === 'full' ? {\n      duration: 0,\n      delay: 0,\n      easing: 'full'\n    } : resolveTiming(metadata.timings, context.errors, true);\n    return {\n      type: AnimationMetadataType.Stagger,\n      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),\n      timings,\n      options: null\n    };\n  }\n}\nfunction normalizeSelector(selector) {\n  const hasAmpersand = selector.split(/\\s*,\\s*/).find(token => token == SELF_TOKEN) ? true : false;\n  if (hasAmpersand) {\n    selector = selector.replace(SELF_TOKEN_REGEX, '');\n  }\n  selector = selector.replace(/@\\*/g, NG_TRIGGER_SELECTOR).replace(/@\\w+/g, match => NG_TRIGGER_SELECTOR + '-' + match.slice(1)).replace(/:animating/g, NG_ANIMATING_SELECTOR);\n  return [selector, hasAmpersand];\n}\nfunction normalizeParams(obj) {\n  return obj ? {\n    ...obj\n  } : null;\n}\nclass AnimationAstBuilderContext {\n  errors;\n  queryCount = 0;\n  depCount = 0;\n  currentTransition = null;\n  currentQuery = null;\n  currentQuerySelector = null;\n  currentAnimateTimings = null;\n  currentTime = 0;\n  collectedStyles = new Map();\n  options = null;\n  unsupportedCSSPropertiesFound = new Set();\n  constructor(errors) {\n    this.errors = errors;\n  }\n}\nfunction consumeOffset(styles) {\n  if (typeof styles == 'string') return null;\n  let offset = null;\n  if (Array.isArray(styles)) {\n    styles.forEach(styleTuple => {\n      if (styleTuple instanceof Map && styleTuple.has('offset')) {\n        const obj = styleTuple;\n        offset = parseFloat(obj.get('offset'));\n        obj.delete('offset');\n      }\n    });\n  } else if (styles instanceof Map && styles.has('offset')) {\n    const obj = styles;\n    offset = parseFloat(obj.get('offset'));\n    obj.delete('offset');\n  }\n  return offset;\n}\nfunction constructTimingAst(value, errors) {\n  if (value.hasOwnProperty('duration')) {\n    return value;\n  }\n  if (typeof value == 'number') {\n    const duration = resolveTiming(value, errors).duration;\n    return makeTimingAst(duration, 0, '');\n  }\n  const strValue = value;\n  const isDynamic = strValue.split(/\\s+/).some(v => v.charAt(0) == '{' && v.charAt(1) == '{');\n  if (isDynamic) {\n    const ast = makeTimingAst(0, 0, '');\n    ast.dynamic = true;\n    ast.strValue = strValue;\n    return ast;\n  }\n  const timings = resolveTiming(strValue, errors);\n  return makeTimingAst(timings.duration, timings.delay, timings.easing);\n}\nfunction normalizeAnimationOptions(options) {\n  if (options) {\n    options = {\n      ...options\n    };\n    if (options['params']) {\n      options['params'] = normalizeParams(options['params']);\n    }\n  } else {\n    options = {};\n  }\n  return options;\n}\nfunction makeTimingAst(duration, delay, easing) {\n  return {\n    duration,\n    delay,\n    easing\n  };\n}\nfunction createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing = null, subTimeline = false) {\n  return {\n    type: 1,\n    element,\n    keyframes,\n    preStyleProps,\n    postStyleProps,\n    duration,\n    delay,\n    totalTime: duration + delay,\n    easing,\n    subTimeline\n  };\n}\nclass ElementInstructionMap {\n  _map = new Map();\n  get(element) {\n    return this._map.get(element) || [];\n  }\n  append(element, instructions) {\n    let existingInstructions = this._map.get(element);\n    if (!existingInstructions) {\n      this._map.set(element, existingInstructions = []);\n    }\n    existingInstructions.push(...instructions);\n  }\n  has(element) {\n    return this._map.has(element);\n  }\n  clear() {\n    this._map.clear();\n  }\n}\nconst ONE_FRAME_IN_MILLISECONDS = 1;\nconst ENTER_TOKEN = ':enter';\nconst ENTER_TOKEN_REGEX = /* @__PURE__ */new RegExp(ENTER_TOKEN, 'g');\nconst LEAVE_TOKEN = ':leave';\nconst LEAVE_TOKEN_REGEX = /* @__PURE__ */new RegExp(LEAVE_TOKEN, 'g');\nfunction buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles = new Map(), finalStyles = new Map(), options, subInstructions, errors = []) {\n  return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);\n}\nclass AnimationTimelineBuilderVisitor {\n  buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors = []) {\n    subInstructions = subInstructions || new ElementInstructionMap();\n    const context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);\n    context.options = options;\n    const delay = options.delay ? resolveTimingValue(options.delay) : 0;\n    context.currentTimeline.delayNextStep(delay);\n    context.currentTimeline.setStyles([startingStyles], null, context.errors, options);\n    visitDslNode(this, ast, context);\n    const timelines = context.timelines.filter(timeline => timeline.containsAnimation());\n    if (timelines.length && finalStyles.size) {\n      let lastRootTimeline;\n      for (let i = timelines.length - 1; i >= 0; i--) {\n        const timeline = timelines[i];\n        if (timeline.element === rootElement) {\n          lastRootTimeline = timeline;\n          break;\n        }\n      }\n      if (lastRootTimeline && !lastRootTimeline.allowOnlyTimelineStyles()) {\n        lastRootTimeline.setStyles([finalStyles], null, context.errors, options);\n      }\n    }\n    return timelines.length ? timelines.map(timeline => timeline.buildKeyframes()) : [createTimelineInstruction(rootElement, [], [], [], 0, delay, '', false)];\n  }\n  visitTrigger(ast, context) {}\n  visitState(ast, context) {}\n  visitTransition(ast, context) {}\n  visitAnimateChild(ast, context) {\n    const elementInstructions = context.subInstructions.get(context.element);\n    if (elementInstructions) {\n      const innerContext = context.createSubContext(ast.options);\n      const startTime = context.currentTimeline.currentTime;\n      const endTime = this._visitSubInstructions(elementInstructions, innerContext, innerContext.options);\n      if (startTime != endTime) {\n        context.transformIntoNewTimeline(endTime);\n      }\n    }\n    context.previousNode = ast;\n  }\n  visitAnimateRef(ast, context) {\n    const innerContext = context.createSubContext(ast.options);\n    innerContext.transformIntoNewTimeline();\n    this._applyAnimationRefDelays([ast.options, ast.animation.options], context, innerContext);\n    this.visitReference(ast.animation, innerContext);\n    context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);\n    context.previousNode = ast;\n  }\n  _applyAnimationRefDelays(animationsRefsOptions, context, innerContext) {\n    for (const animationRefOptions of animationsRefsOptions) {\n      const animationDelay = animationRefOptions?.delay;\n      if (animationDelay) {\n        const animationDelayValue = typeof animationDelay === 'number' ? animationDelay : resolveTimingValue(interpolateParams(animationDelay, animationRefOptions?.params ?? {}, context.errors));\n        innerContext.delayNextStep(animationDelayValue);\n      }\n    }\n  }\n  _visitSubInstructions(instructions, context, options) {\n    const startTime = context.currentTimeline.currentTime;\n    let furthestTime = startTime;\n    const duration = options.duration != null ? resolveTimingValue(options.duration) : null;\n    const delay = options.delay != null ? resolveTimingValue(options.delay) : null;\n    if (duration !== 0) {\n      instructions.forEach(instruction => {\n        const instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);\n        furthestTime = Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);\n      });\n    }\n    return furthestTime;\n  }\n  visitReference(ast, context) {\n    context.updateOptions(ast.options, true);\n    visitDslNode(this, ast.animation, context);\n    context.previousNode = ast;\n  }\n  visitSequence(ast, context) {\n    const subContextCount = context.subContextCount;\n    let ctx = context;\n    const options = ast.options;\n    if (options && (options.params || options.delay)) {\n      ctx = context.createSubContext(options);\n      ctx.transformIntoNewTimeline();\n      if (options.delay != null) {\n        if (ctx.previousNode.type == AnimationMetadataType.Style) {\n          ctx.currentTimeline.snapshotCurrentStyles();\n          ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n        }\n        const delay = resolveTimingValue(options.delay);\n        ctx.delayNextStep(delay);\n      }\n    }\n    if (ast.steps.length) {\n      ast.steps.forEach(s => visitDslNode(this, s, ctx));\n      ctx.currentTimeline.applyStylesToKeyframe();\n      if (ctx.subContextCount > subContextCount) {\n        ctx.transformIntoNewTimeline();\n      }\n    }\n    context.previousNode = ast;\n  }\n  visitGroup(ast, context) {\n    const innerTimelines = [];\n    let furthestTime = context.currentTimeline.currentTime;\n    const delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;\n    ast.steps.forEach(s => {\n      const innerContext = context.createSubContext(ast.options);\n      if (delay) {\n        innerContext.delayNextStep(delay);\n      }\n      visitDslNode(this, s, innerContext);\n      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);\n      innerTimelines.push(innerContext.currentTimeline);\n    });\n    innerTimelines.forEach(timeline => context.currentTimeline.mergeTimelineCollectedStyles(timeline));\n    context.transformIntoNewTimeline(furthestTime);\n    context.previousNode = ast;\n  }\n  _visitTiming(ast, context) {\n    if (ast.dynamic) {\n      const strValue = ast.strValue;\n      const timingValue = context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;\n      return resolveTiming(timingValue, context.errors);\n    } else {\n      return {\n        duration: ast.duration,\n        delay: ast.delay,\n        easing: ast.easing\n      };\n    }\n  }\n  visitAnimate(ast, context) {\n    const timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);\n    const timeline = context.currentTimeline;\n    if (timings.delay) {\n      context.incrementTime(timings.delay);\n      timeline.snapshotCurrentStyles();\n    }\n    const style = ast.style;\n    if (style.type == AnimationMetadataType.Keyframes) {\n      this.visitKeyframes(style, context);\n    } else {\n      context.incrementTime(timings.duration);\n      this.visitStyle(style, context);\n      timeline.applyStylesToKeyframe();\n    }\n    context.currentAnimateTimings = null;\n    context.previousNode = ast;\n  }\n  visitStyle(ast, context) {\n    const timeline = context.currentTimeline;\n    const timings = context.currentAnimateTimings;\n    if (!timings && timeline.hasCurrentStyleProperties()) {\n      timeline.forwardFrame();\n    }\n    const easing = timings && timings.easing || ast.easing;\n    if (ast.isEmptyStep) {\n      timeline.applyEmptyStep(easing);\n    } else {\n      timeline.setStyles(ast.styles, easing, context.errors, context.options);\n    }\n    context.previousNode = ast;\n  }\n  visitKeyframes(ast, context) {\n    const currentAnimateTimings = context.currentAnimateTimings;\n    const startTime = context.currentTimeline.duration;\n    const duration = currentAnimateTimings.duration;\n    const innerContext = context.createSubContext();\n    const innerTimeline = innerContext.currentTimeline;\n    innerTimeline.easing = currentAnimateTimings.easing;\n    ast.styles.forEach(step => {\n      const offset = step.offset || 0;\n      innerTimeline.forwardTime(offset * duration);\n      innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);\n      innerTimeline.applyStylesToKeyframe();\n    });\n    context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);\n    context.transformIntoNewTimeline(startTime + duration);\n    context.previousNode = ast;\n  }\n  visitQuery(ast, context) {\n    const startTime = context.currentTimeline.currentTime;\n    const options = ast.options || {};\n    const delay = options.delay ? resolveTimingValue(options.delay) : 0;\n    if (delay && (context.previousNode.type === AnimationMetadataType.Style || startTime == 0 && context.currentTimeline.hasCurrentStyleProperties())) {\n      context.currentTimeline.snapshotCurrentStyles();\n      context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n    }\n    let furthestTime = startTime;\n    const elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);\n    context.currentQueryTotal = elms.length;\n    let sameElementTimeline = null;\n    elms.forEach((element, i) => {\n      context.currentQueryIndex = i;\n      const innerContext = context.createSubContext(ast.options, element);\n      if (delay) {\n        innerContext.delayNextStep(delay);\n      }\n      if (element === context.element) {\n        sameElementTimeline = innerContext.currentTimeline;\n      }\n      visitDslNode(this, ast.animation, innerContext);\n      innerContext.currentTimeline.applyStylesToKeyframe();\n      const endTime = innerContext.currentTimeline.currentTime;\n      furthestTime = Math.max(furthestTime, endTime);\n    });\n    context.currentQueryIndex = 0;\n    context.currentQueryTotal = 0;\n    context.transformIntoNewTimeline(furthestTime);\n    if (sameElementTimeline) {\n      context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);\n      context.currentTimeline.snapshotCurrentStyles();\n    }\n    context.previousNode = ast;\n  }\n  visitStagger(ast, context) {\n    const parentContext = context.parentContext;\n    const tl = context.currentTimeline;\n    const timings = ast.timings;\n    const duration = Math.abs(timings.duration);\n    const maxTime = duration * (context.currentQueryTotal - 1);\n    let delay = duration * context.currentQueryIndex;\n    let staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;\n    switch (staggerTransformer) {\n      case 'reverse':\n        delay = maxTime - delay;\n        break;\n      case 'full':\n        delay = parentContext.currentStaggerTime;\n        break;\n    }\n    const timeline = context.currentTimeline;\n    if (delay) {\n      timeline.delayNextStep(delay);\n    }\n    const startingTime = timeline.currentTime;\n    visitDslNode(this, ast.animation, context);\n    context.previousNode = ast;\n    parentContext.currentStaggerTime = tl.currentTime - startingTime + (tl.startTime - parentContext.currentTimeline.startTime);\n  }\n}\nconst DEFAULT_NOOP_PREVIOUS_NODE = {};\nclass AnimationTimelineContext {\n  _driver;\n  element;\n  subInstructions;\n  _enterClassName;\n  _leaveClassName;\n  errors;\n  timelines;\n  parentContext = null;\n  currentTimeline;\n  currentAnimateTimings = null;\n  previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n  subContextCount = 0;\n  options = {};\n  currentQueryIndex = 0;\n  currentQueryTotal = 0;\n  currentStaggerTime = 0;\n  constructor(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {\n    this._driver = _driver;\n    this.element = element;\n    this.subInstructions = subInstructions;\n    this._enterClassName = _enterClassName;\n    this._leaveClassName = _leaveClassName;\n    this.errors = errors;\n    this.timelines = timelines;\n    this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);\n    timelines.push(this.currentTimeline);\n  }\n  get params() {\n    return this.options.params;\n  }\n  updateOptions(options, skipIfExists) {\n    if (!options) return;\n    const newOptions = options;\n    let optionsToUpdate = this.options;\n    if (newOptions.duration != null) {\n      optionsToUpdate.duration = resolveTimingValue(newOptions.duration);\n    }\n    if (newOptions.delay != null) {\n      optionsToUpdate.delay = resolveTimingValue(newOptions.delay);\n    }\n    const newParams = newOptions.params;\n    if (newParams) {\n      let paramsToUpdate = optionsToUpdate.params;\n      if (!paramsToUpdate) {\n        paramsToUpdate = this.options.params = {};\n      }\n      Object.keys(newParams).forEach(name => {\n        if (!skipIfExists || !paramsToUpdate.hasOwnProperty(name)) {\n          paramsToUpdate[name] = interpolateParams(newParams[name], paramsToUpdate, this.errors);\n        }\n      });\n    }\n  }\n  _copyOptions() {\n    const options = {};\n    if (this.options) {\n      const oldParams = this.options.params;\n      if (oldParams) {\n        const params = options['params'] = {};\n        Object.keys(oldParams).forEach(name => {\n          params[name] = oldParams[name];\n        });\n      }\n    }\n    return options;\n  }\n  createSubContext(options = null, element, newTime) {\n    const target = element || this.element;\n    const context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));\n    context.previousNode = this.previousNode;\n    context.currentAnimateTimings = this.currentAnimateTimings;\n    context.options = this._copyOptions();\n    context.updateOptions(options);\n    context.currentQueryIndex = this.currentQueryIndex;\n    context.currentQueryTotal = this.currentQueryTotal;\n    context.parentContext = this;\n    this.subContextCount++;\n    return context;\n  }\n  transformIntoNewTimeline(newTime) {\n    this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n    this.currentTimeline = this.currentTimeline.fork(this.element, newTime);\n    this.timelines.push(this.currentTimeline);\n    return this.currentTimeline;\n  }\n  appendInstructionToTimeline(instruction, duration, delay) {\n    const updatedTimings = {\n      duration: duration != null ? duration : instruction.duration,\n      delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,\n      easing: ''\n    };\n    const builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);\n    this.timelines.push(builder);\n    return updatedTimings;\n  }\n  incrementTime(time) {\n    this.currentTimeline.forwardTime(this.currentTimeline.duration + time);\n  }\n  delayNextStep(delay) {\n    if (delay > 0) {\n      this.currentTimeline.delayNextStep(delay);\n    }\n  }\n  invokeQuery(selector, originalSelector, limit, includeSelf, optional, errors) {\n    let results = [];\n    if (includeSelf) {\n      results.push(this.element);\n    }\n    if (selector.length > 0) {\n      selector = selector.replace(ENTER_TOKEN_REGEX, '.' + this._enterClassName);\n      selector = selector.replace(LEAVE_TOKEN_REGEX, '.' + this._leaveClassName);\n      const multi = limit != 1;\n      let elements = this._driver.query(this.element, selector, multi);\n      if (limit !== 0) {\n        elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) : elements.slice(0, limit);\n      }\n      results.push(...elements);\n    }\n    if (!optional && results.length == 0) {\n      errors.push(invalidQuery(originalSelector));\n    }\n    return results;\n  }\n}\nclass TimelineBuilder {\n  _driver;\n  element;\n  startTime;\n  _elementTimelineStylesLookup;\n  duration = 0;\n  easing = null;\n  _previousKeyframe = new Map();\n  _currentKeyframe = new Map();\n  _keyframes = new Map();\n  _styleSummary = new Map();\n  _localTimelineStyles = new Map();\n  _globalTimelineStyles;\n  _pendingStyles = new Map();\n  _backFill = new Map();\n  _currentEmptyStepKeyframe = null;\n  constructor(_driver, element, startTime, _elementTimelineStylesLookup) {\n    this._driver = _driver;\n    this.element = element;\n    this.startTime = startTime;\n    this._elementTimelineStylesLookup = _elementTimelineStylesLookup;\n    if (!this._elementTimelineStylesLookup) {\n      this._elementTimelineStylesLookup = new Map();\n    }\n    this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element);\n    if (!this._globalTimelineStyles) {\n      this._globalTimelineStyles = this._localTimelineStyles;\n      this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);\n    }\n    this._loadKeyframe();\n  }\n  containsAnimation() {\n    switch (this._keyframes.size) {\n      case 0:\n        return false;\n      case 1:\n        return this.hasCurrentStyleProperties();\n      default:\n        return true;\n    }\n  }\n  hasCurrentStyleProperties() {\n    return this._currentKeyframe.size > 0;\n  }\n  get currentTime() {\n    return this.startTime + this.duration;\n  }\n  delayNextStep(delay) {\n    const hasPreStyleStep = this._keyframes.size === 1 && this._pendingStyles.size;\n    if (this.duration || hasPreStyleStep) {\n      this.forwardTime(this.currentTime + delay);\n      if (hasPreStyleStep) {\n        this.snapshotCurrentStyles();\n      }\n    } else {\n      this.startTime += delay;\n    }\n  }\n  fork(element, currentTime) {\n    this.applyStylesToKeyframe();\n    return new TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);\n  }\n  _loadKeyframe() {\n    if (this._currentKeyframe) {\n      this._previousKeyframe = this._currentKeyframe;\n    }\n    this._currentKeyframe = this._keyframes.get(this.duration);\n    if (!this._currentKeyframe) {\n      this._currentKeyframe = new Map();\n      this._keyframes.set(this.duration, this._currentKeyframe);\n    }\n  }\n  forwardFrame() {\n    this.duration += ONE_FRAME_IN_MILLISECONDS;\n    this._loadKeyframe();\n  }\n  forwardTime(time) {\n    this.applyStylesToKeyframe();\n    this.duration = time;\n    this._loadKeyframe();\n  }\n  _updateStyle(prop, value) {\n    this._localTimelineStyles.set(prop, value);\n    this._globalTimelineStyles.set(prop, value);\n    this._styleSummary.set(prop, {\n      time: this.currentTime,\n      value\n    });\n  }\n  allowOnlyTimelineStyles() {\n    return this._currentEmptyStepKeyframe !== this._currentKeyframe;\n  }\n  applyEmptyStep(easing) {\n    if (easing) {\n      this._previousKeyframe.set('easing', easing);\n    }\n    for (let [prop, value] of this._globalTimelineStyles) {\n      this._backFill.set(prop, value || AUTO_STYLE);\n      this._currentKeyframe.set(prop, AUTO_STYLE);\n    }\n    this._currentEmptyStepKeyframe = this._currentKeyframe;\n  }\n  setStyles(input, easing, errors, options) {\n    if (easing) {\n      this._previousKeyframe.set('easing', easing);\n    }\n    const params = options && options.params || {};\n    const styles = flattenStyles(input, this._globalTimelineStyles);\n    for (let [prop, value] of styles) {\n      const val = interpolateParams(value, params, errors);\n      this._pendingStyles.set(prop, val);\n      if (!this._localTimelineStyles.has(prop)) {\n        this._backFill.set(prop, this._globalTimelineStyles.get(prop) ?? AUTO_STYLE);\n      }\n      this._updateStyle(prop, val);\n    }\n  }\n  applyStylesToKeyframe() {\n    if (this._pendingStyles.size == 0) return;\n    this._pendingStyles.forEach((val, prop) => {\n      this._currentKeyframe.set(prop, val);\n    });\n    this._pendingStyles.clear();\n    this._localTimelineStyles.forEach((val, prop) => {\n      if (!this._currentKeyframe.has(prop)) {\n        this._currentKeyframe.set(prop, val);\n      }\n    });\n  }\n  snapshotCurrentStyles() {\n    for (let [prop, val] of this._localTimelineStyles) {\n      this._pendingStyles.set(prop, val);\n      this._updateStyle(prop, val);\n    }\n  }\n  getFinalKeyframe() {\n    return this._keyframes.get(this.duration);\n  }\n  get properties() {\n    const properties = [];\n    for (let prop in this._currentKeyframe) {\n      properties.push(prop);\n    }\n    return properties;\n  }\n  mergeTimelineCollectedStyles(timeline) {\n    timeline._styleSummary.forEach((details1, prop) => {\n      const details0 = this._styleSummary.get(prop);\n      if (!details0 || details1.time > details0.time) {\n        this._updateStyle(prop, details1.value);\n      }\n    });\n  }\n  buildKeyframes() {\n    this.applyStylesToKeyframe();\n    const preStyleProps = new Set();\n    const postStyleProps = new Set();\n    const isEmpty = this._keyframes.size === 1 && this.duration === 0;\n    let finalKeyframes = [];\n    this._keyframes.forEach((keyframe, time) => {\n      const finalKeyframe = new Map([...this._backFill, ...keyframe]);\n      finalKeyframe.forEach((value, prop) => {\n        if (value === _PRE_STYLE) {\n          preStyleProps.add(prop);\n        } else if (value === AUTO_STYLE) {\n          postStyleProps.add(prop);\n        }\n      });\n      if (!isEmpty) {\n        finalKeyframe.set('offset', time / this.duration);\n      }\n      finalKeyframes.push(finalKeyframe);\n    });\n    const preProps = [...preStyleProps.values()];\n    const postProps = [...postStyleProps.values()];\n    if (isEmpty) {\n      const kf0 = finalKeyframes[0];\n      const kf1 = new Map(kf0);\n      kf0.set('offset', 0);\n      kf1.set('offset', 1);\n      finalKeyframes = [kf0, kf1];\n    }\n    return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);\n  }\n}\nclass SubTimelineBuilder extends TimelineBuilder {\n  keyframes;\n  preStyleProps;\n  postStyleProps;\n  _stretchStartingKeyframe;\n  timings;\n  constructor(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe = false) {\n    super(driver, element, timings.delay);\n    this.keyframes = keyframes;\n    this.preStyleProps = preStyleProps;\n    this.postStyleProps = postStyleProps;\n    this._stretchStartingKeyframe = _stretchStartingKeyframe;\n    this.timings = {\n      duration: timings.duration,\n      delay: timings.delay,\n      easing: timings.easing\n    };\n  }\n  containsAnimation() {\n    return this.keyframes.length > 1;\n  }\n  buildKeyframes() {\n    let keyframes = this.keyframes;\n    let {\n      delay,\n      duration,\n      easing\n    } = this.timings;\n    if (this._stretchStartingKeyframe && delay) {\n      const newKeyframes = [];\n      const totalTime = duration + delay;\n      const startingGap = delay / totalTime;\n      const newFirstKeyframe = new Map(keyframes[0]);\n      newFirstKeyframe.set('offset', 0);\n      newKeyframes.push(newFirstKeyframe);\n      const oldFirstKeyframe = new Map(keyframes[0]);\n      oldFirstKeyframe.set('offset', roundOffset(startingGap));\n      newKeyframes.push(oldFirstKeyframe);\n      const limit = keyframes.length - 1;\n      for (let i = 1; i <= limit; i++) {\n        let kf = new Map(keyframes[i]);\n        const oldOffset = kf.get('offset');\n        const timeAtKeyframe = delay + oldOffset * duration;\n        kf.set('offset', roundOffset(timeAtKeyframe / totalTime));\n        newKeyframes.push(kf);\n      }\n      duration = totalTime;\n      delay = 0;\n      easing = '';\n      keyframes = newKeyframes;\n    }\n    return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);\n  }\n}\nfunction roundOffset(offset, decimalPoints = 3) {\n  const mult = Math.pow(10, decimalPoints - 1);\n  return Math.round(offset * mult) / mult;\n}\nfunction flattenStyles(input, allStyles) {\n  const styles = new Map();\n  let allProperties;\n  input.forEach(token => {\n    if (token === '*') {\n      allProperties ??= allStyles.keys();\n      for (let prop of allProperties) {\n        styles.set(prop, AUTO_STYLE);\n      }\n    } else {\n      for (let [prop, val] of token) {\n        styles.set(prop, val);\n      }\n    }\n  });\n  return styles;\n}\nfunction createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {\n  return {\n    type: 0,\n    element,\n    triggerName,\n    isRemovalTransition,\n    fromState,\n    fromStyles,\n    toState,\n    toStyles,\n    timelines,\n    queriedElements,\n    preStyleProps,\n    postStyleProps,\n    totalTime,\n    errors\n  };\n}\nconst EMPTY_OBJECT = {};\nclass AnimationTransitionFactory {\n  _triggerName;\n  ast;\n  _stateStyles;\n  constructor(_triggerName, ast, _stateStyles) {\n    this._triggerName = _triggerName;\n    this.ast = ast;\n    this._stateStyles = _stateStyles;\n  }\n  match(currentState, nextState, element, params) {\n    return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState, element, params);\n  }\n  buildStyles(stateName, params, errors) {\n    let styler = this._stateStyles.get('*');\n    if (stateName !== undefined) {\n      styler = this._stateStyles.get(stateName?.toString()) || styler;\n    }\n    return styler ? styler.buildStyles(params, errors) : new Map();\n  }\n  build(driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {\n    const errors = [];\n    const transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;\n    const currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;\n    const currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);\n    const nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;\n    const nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);\n    const queriedElements = new Set();\n    const preStyleMap = new Map();\n    const postStyleMap = new Map();\n    const isRemoval = nextState === 'void';\n    const animationOptions = {\n      params: applyParamDefaults(nextAnimationParams, transitionAnimationParams),\n      delay: this.ast.options?.delay\n    };\n    const timelines = skipAstBuild ? [] : buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);\n    let totalTime = 0;\n    timelines.forEach(tl => {\n      totalTime = Math.max(tl.duration + tl.delay, totalTime);\n    });\n    if (errors.length) {\n      return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);\n    }\n    timelines.forEach(tl => {\n      const elm = tl.element;\n      const preProps = getOrSetDefaultValue(preStyleMap, elm, new Set());\n      tl.preStyleProps.forEach(prop => preProps.add(prop));\n      const postProps = getOrSetDefaultValue(postStyleMap, elm, new Set());\n      tl.postStyleProps.forEach(prop => postProps.add(prop));\n      if (elm !== element) {\n        queriedElements.add(elm);\n      }\n    });\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      checkNonAnimatableInTimelines(timelines, this._triggerName, driver);\n    }\n    return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, [...queriedElements.values()], preStyleMap, postStyleMap, totalTime);\n  }\n}\nfunction checkNonAnimatableInTimelines(timelines, triggerName, driver) {\n  if (!driver.validateAnimatableStyleProperty) {\n    return;\n  }\n  const allowedNonAnimatableProps = new Set(['easing']);\n  const invalidNonAnimatableProps = new Set();\n  timelines.forEach(({\n    keyframes\n  }) => {\n    const nonAnimatablePropsInitialValues = new Map();\n    keyframes.forEach(keyframe => {\n      const entriesToCheck = Array.from(keyframe.entries()).filter(([prop]) => !allowedNonAnimatableProps.has(prop));\n      for (const [prop, value] of entriesToCheck) {\n        if (!driver.validateAnimatableStyleProperty(prop)) {\n          if (nonAnimatablePropsInitialValues.has(prop) && !invalidNonAnimatableProps.has(prop)) {\n            const propInitialValue = nonAnimatablePropsInitialValues.get(prop);\n            if (propInitialValue !== value) {\n              invalidNonAnimatableProps.add(prop);\n            }\n          } else {\n            nonAnimatablePropsInitialValues.set(prop, value);\n          }\n        }\n      }\n    });\n  });\n  if (invalidNonAnimatableProps.size > 0) {\n    console.warn(`Warning: The animation trigger \"${triggerName}\" is attempting to animate the following` + ' not animatable properties: ' + Array.from(invalidNonAnimatableProps).join(', ') + '\\n' + '(to check the list of all animatable properties visit https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties)');\n  }\n}\nfunction oneOrMoreTransitionsMatch(matchFns, currentState, nextState, element, params) {\n  return matchFns.some(fn => fn(currentState, nextState, element, params));\n}\nfunction applyParamDefaults(userParams, defaults) {\n  const result = {\n    ...defaults\n  };\n  Object.entries(userParams).forEach(([key, value]) => {\n    if (value != null) {\n      result[key] = value;\n    }\n  });\n  return result;\n}\nclass AnimationStateStyles {\n  styles;\n  defaultParams;\n  normalizer;\n  constructor(styles, defaultParams, normalizer) {\n    this.styles = styles;\n    this.defaultParams = defaultParams;\n    this.normalizer = normalizer;\n  }\n  buildStyles(params, errors) {\n    const finalStyles = new Map();\n    const combinedParams = applyParamDefaults(params, this.defaultParams);\n    this.styles.styles.forEach(value => {\n      if (typeof value !== 'string') {\n        value.forEach((val, prop) => {\n          if (val) {\n            val = interpolateParams(val, combinedParams, errors);\n          }\n          const normalizedProp = this.normalizer.normalizePropertyName(prop, errors);\n          val = this.normalizer.normalizeStyleValue(prop, normalizedProp, val, errors);\n          finalStyles.set(prop, val);\n        });\n      }\n    });\n    return finalStyles;\n  }\n}\nfunction buildTrigger(name, ast, normalizer) {\n  return new AnimationTrigger(name, ast, normalizer);\n}\nclass AnimationTrigger {\n  name;\n  ast;\n  _normalizer;\n  transitionFactories = [];\n  fallbackTransition;\n  states = new Map();\n  constructor(name, ast, _normalizer) {\n    this.name = name;\n    this.ast = ast;\n    this._normalizer = _normalizer;\n    ast.states.forEach(ast => {\n      const defaultParams = ast.options && ast.options.params || {};\n      this.states.set(ast.name, new AnimationStateStyles(ast.style, defaultParams, _normalizer));\n    });\n    balanceProperties(this.states, 'true', '1');\n    balanceProperties(this.states, 'false', '0');\n    ast.transitions.forEach(ast => {\n      this.transitionFactories.push(new AnimationTransitionFactory(name, ast, this.states));\n    });\n    this.fallbackTransition = createFallbackTransition(name, this.states);\n  }\n  get containsQueries() {\n    return this.ast.queryCount > 0;\n  }\n  matchTransition(currentState, nextState, element, params) {\n    const entry = this.transitionFactories.find(f => f.match(currentState, nextState, element, params));\n    return entry || null;\n  }\n  matchStyles(currentState, params, errors) {\n    return this.fallbackTransition.buildStyles(currentState, params, errors);\n  }\n}\nfunction createFallbackTransition(triggerName, states, normalizer) {\n  const matchers = [(fromState, toState) => true];\n  const animation = {\n    type: AnimationMetadataType.Sequence,\n    steps: [],\n    options: null\n  };\n  const transition = {\n    type: AnimationMetadataType.Transition,\n    animation,\n    matchers,\n    options: null,\n    queryCount: 0,\n    depCount: 0\n  };\n  return new AnimationTransitionFactory(triggerName, transition, states);\n}\nfunction balanceProperties(stateMap, key1, key2) {\n  if (stateMap.has(key1)) {\n    if (!stateMap.has(key2)) {\n      stateMap.set(key2, stateMap.get(key1));\n    }\n  } else if (stateMap.has(key2)) {\n    stateMap.set(key1, stateMap.get(key2));\n  }\n}\nconst EMPTY_INSTRUCTION_MAP = /* @__PURE__ */new ElementInstructionMap();\nclass TimelineAnimationEngine {\n  bodyNode;\n  _driver;\n  _normalizer;\n  _animations = new Map();\n  _playersById = new Map();\n  players = [];\n  constructor(bodyNode, _driver, _normalizer) {\n    this.bodyNode = bodyNode;\n    this._driver = _driver;\n    this._normalizer = _normalizer;\n  }\n  register(id, metadata) {\n    const errors = [];\n    const warnings = [];\n    const ast = buildAnimationAst(this._driver, metadata, errors, warnings);\n    if (errors.length) {\n      throw registerFailed(errors);\n    } else {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (warnings.length) {\n          warnRegister(warnings);\n        }\n      }\n      this._animations.set(id, ast);\n    }\n  }\n  _buildPlayer(i, preStyles, postStyles) {\n    const element = i.element;\n    const keyframes = normalizeKeyframes(this._normalizer, i.keyframes, preStyles, postStyles);\n    return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, [], true);\n  }\n  create(id, element, options = {}) {\n    const errors = [];\n    const ast = this._animations.get(id);\n    let instructions;\n    const autoStylesMap = new Map();\n    if (ast) {\n      instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, new Map(), new Map(), options, EMPTY_INSTRUCTION_MAP, errors);\n      instructions.forEach(inst => {\n        const styles = getOrSetDefaultValue(autoStylesMap, inst.element, new Map());\n        inst.postStyleProps.forEach(prop => styles.set(prop, null));\n      });\n    } else {\n      errors.push(missingOrDestroyedAnimation());\n      instructions = [];\n    }\n    if (errors.length) {\n      throw createAnimationFailed(errors);\n    }\n    autoStylesMap.forEach((styles, element) => {\n      styles.forEach((_, prop) => {\n        styles.set(prop, this._driver.computeStyle(element, prop, AUTO_STYLE));\n      });\n    });\n    const players = instructions.map(i => {\n      const styles = autoStylesMap.get(i.element);\n      return this._buildPlayer(i, new Map(), styles);\n    });\n    const player = optimizeGroupPlayer(players);\n    this._playersById.set(id, player);\n    player.onDestroy(() => this.destroy(id));\n    this.players.push(player);\n    return player;\n  }\n  destroy(id) {\n    const player = this._getPlayer(id);\n    player.destroy();\n    this._playersById.delete(id);\n    const index = this.players.indexOf(player);\n    if (index >= 0) {\n      this.players.splice(index, 1);\n    }\n  }\n  _getPlayer(id) {\n    const player = this._playersById.get(id);\n    if (!player) {\n      throw missingPlayer(id);\n    }\n    return player;\n  }\n  listen(id, element, eventName, callback) {\n    const baseEvent = makeAnimationEvent(element, '', '', '');\n    listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);\n    return () => {};\n  }\n  command(id, element, command, args) {\n    if (command == 'register') {\n      this.register(id, args[0]);\n      return;\n    }\n    if (command == 'create') {\n      const options = args[0] || {};\n      this.create(id, element, options);\n      return;\n    }\n    const player = this._getPlayer(id);\n    switch (command) {\n      case 'play':\n        player.play();\n        break;\n      case 'pause':\n        player.pause();\n        break;\n      case 'reset':\n        player.reset();\n        break;\n      case 'restart':\n        player.restart();\n        break;\n      case 'finish':\n        player.finish();\n        break;\n      case 'init':\n        player.init();\n        break;\n      case 'setPosition':\n        player.setPosition(parseFloat(args[0]));\n        break;\n      case 'destroy':\n        this.destroy(id);\n        break;\n    }\n  }\n}\nconst QUEUED_CLASSNAME = 'ng-animate-queued';\nconst QUEUED_SELECTOR = '.ng-animate-queued';\nconst DISABLED_CLASSNAME = 'ng-animate-disabled';\nconst DISABLED_SELECTOR = '.ng-animate-disabled';\nconst STAR_CLASSNAME = 'ng-star-inserted';\nconst STAR_SELECTOR = '.ng-star-inserted';\nconst EMPTY_PLAYER_ARRAY = [];\nconst NULL_REMOVAL_STATE = {\n  namespaceId: '',\n  setForRemoval: false,\n  setForMove: false,\n  hasAnimation: false,\n  removedBeforeQueried: false\n};\nconst NULL_REMOVED_QUERIED_STATE = {\n  namespaceId: '',\n  setForMove: false,\n  setForRemoval: false,\n  hasAnimation: false,\n  removedBeforeQueried: true\n};\nconst REMOVAL_FLAG = '__ng_removed';\nclass StateValue {\n  namespaceId;\n  value;\n  options;\n  get params() {\n    return this.options.params;\n  }\n  constructor(input, namespaceId = '') {\n    this.namespaceId = namespaceId;\n    const isObj = input && input.hasOwnProperty('value');\n    const value = isObj ? input['value'] : input;\n    this.value = normalizeTriggerValue(value);\n    if (isObj) {\n      const {\n        value,\n        ...options\n      } = input;\n      this.options = options;\n    } else {\n      this.options = {};\n    }\n    if (!this.options.params) {\n      this.options.params = {};\n    }\n  }\n  absorbOptions(options) {\n    const newParams = options.params;\n    if (newParams) {\n      const oldParams = this.options.params;\n      Object.keys(newParams).forEach(prop => {\n        if (oldParams[prop] == null) {\n          oldParams[prop] = newParams[prop];\n        }\n      });\n    }\n  }\n}\nconst VOID_VALUE = 'void';\nconst DEFAULT_STATE_VALUE = /* @__PURE__ */new StateValue(VOID_VALUE);\nclass AnimationTransitionNamespace {\n  id;\n  hostElement;\n  _engine;\n  players = [];\n  _triggers = new Map();\n  _queue = [];\n  _elementListeners = new Map();\n  _hostClassName;\n  constructor(id, hostElement, _engine) {\n    this.id = id;\n    this.hostElement = hostElement;\n    this._engine = _engine;\n    this._hostClassName = 'ng-tns-' + id;\n    addClass(hostElement, this._hostClassName);\n  }\n  listen(element, name, phase, callback) {\n    if (!this._triggers.has(name)) {\n      throw missingTrigger(phase, name);\n    }\n    if (phase == null || phase.length == 0) {\n      throw missingEvent(name);\n    }\n    if (!isTriggerEventValid(phase)) {\n      throw unsupportedTriggerEvent(phase, name);\n    }\n    const listeners = getOrSetDefaultValue(this._elementListeners, element, []);\n    const data = {\n      name,\n      phase,\n      callback\n    };\n    listeners.push(data);\n    const triggersWithStates = getOrSetDefaultValue(this._engine.statesByElement, element, new Map());\n    if (!triggersWithStates.has(name)) {\n      addClass(element, NG_TRIGGER_CLASSNAME);\n      addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);\n      triggersWithStates.set(name, DEFAULT_STATE_VALUE);\n    }\n    return () => {\n      this._engine.afterFlush(() => {\n        const index = listeners.indexOf(data);\n        if (index >= 0) {\n          listeners.splice(index, 1);\n        }\n        if (!this._triggers.has(name)) {\n          triggersWithStates.delete(name);\n        }\n      });\n    };\n  }\n  register(name, ast) {\n    if (this._triggers.has(name)) {\n      return false;\n    } else {\n      this._triggers.set(name, ast);\n      return true;\n    }\n  }\n  _getTrigger(name) {\n    const trigger = this._triggers.get(name);\n    if (!trigger) {\n      throw unregisteredTrigger(name);\n    }\n    return trigger;\n  }\n  trigger(element, triggerName, value, defaultToFallback = true) {\n    const trigger = this._getTrigger(triggerName);\n    const player = new TransitionAnimationPlayer(this.id, triggerName, element);\n    let triggersWithStates = this._engine.statesByElement.get(element);\n    if (!triggersWithStates) {\n      addClass(element, NG_TRIGGER_CLASSNAME);\n      addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);\n      this._engine.statesByElement.set(element, triggersWithStates = new Map());\n    }\n    let fromState = triggersWithStates.get(triggerName);\n    const toState = new StateValue(value, this.id);\n    const isObj = value && value.hasOwnProperty('value');\n    if (!isObj && fromState) {\n      toState.absorbOptions(fromState.options);\n    }\n    triggersWithStates.set(triggerName, toState);\n    if (!fromState) {\n      fromState = DEFAULT_STATE_VALUE;\n    }\n    const isRemoval = toState.value === VOID_VALUE;\n    if (!isRemoval && fromState.value === toState.value) {\n      if (!objEquals(fromState.params, toState.params)) {\n        const errors = [];\n        const fromStyles = trigger.matchStyles(fromState.value, fromState.params, errors);\n        const toStyles = trigger.matchStyles(toState.value, toState.params, errors);\n        if (errors.length) {\n          this._engine.reportError(errors);\n        } else {\n          this._engine.afterFlush(() => {\n            eraseStyles(element, fromStyles);\n            setStyles(element, toStyles);\n          });\n        }\n      }\n      return;\n    }\n    const playersOnElement = getOrSetDefaultValue(this._engine.playersByElement, element, []);\n    playersOnElement.forEach(player => {\n      if (player.namespaceId == this.id && player.triggerName == triggerName && player.queued) {\n        player.destroy();\n      }\n    });\n    let transition = trigger.matchTransition(fromState.value, toState.value, element, toState.params);\n    let isFallbackTransition = false;\n    if (!transition) {\n      if (!defaultToFallback) return;\n      transition = trigger.fallbackTransition;\n      isFallbackTransition = true;\n    }\n    this._engine.totalQueuedPlayers++;\n    this._queue.push({\n      element,\n      triggerName,\n      transition,\n      fromState,\n      toState,\n      player,\n      isFallbackTransition\n    });\n    if (!isFallbackTransition) {\n      addClass(element, QUEUED_CLASSNAME);\n      player.onStart(() => {\n        removeClass(element, QUEUED_CLASSNAME);\n      });\n    }\n    player.onDone(() => {\n      let index = this.players.indexOf(player);\n      if (index >= 0) {\n        this.players.splice(index, 1);\n      }\n      const players = this._engine.playersByElement.get(element);\n      if (players) {\n        let index = players.indexOf(player);\n        if (index >= 0) {\n          players.splice(index, 1);\n        }\n      }\n    });\n    this.players.push(player);\n    playersOnElement.push(player);\n    return player;\n  }\n  deregister(name) {\n    this._triggers.delete(name);\n    this._engine.statesByElement.forEach(stateMap => stateMap.delete(name));\n    this._elementListeners.forEach((listeners, element) => {\n      this._elementListeners.set(element, listeners.filter(entry => {\n        return entry.name != name;\n      }));\n    });\n  }\n  clearElementCache(element) {\n    this._engine.statesByElement.delete(element);\n    this._elementListeners.delete(element);\n    const elementPlayers = this._engine.playersByElement.get(element);\n    if (elementPlayers) {\n      elementPlayers.forEach(player => player.destroy());\n      this._engine.playersByElement.delete(element);\n    }\n  }\n  _signalRemovalForInnerTriggers(rootElement, context) {\n    const elements = this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true);\n    elements.forEach(elm => {\n      if (elm[REMOVAL_FLAG]) return;\n      const namespaces = this._engine.fetchNamespacesByElement(elm);\n      if (namespaces.size) {\n        namespaces.forEach(ns => ns.triggerLeaveAnimation(elm, context, false, true));\n      } else {\n        this.clearElementCache(elm);\n      }\n    });\n    this._engine.afterFlushAnimationsDone(() => elements.forEach(elm => this.clearElementCache(elm)));\n  }\n  triggerLeaveAnimation(element, context, destroyAfterComplete, defaultToFallback) {\n    const triggerStates = this._engine.statesByElement.get(element);\n    const previousTriggersValues = new Map();\n    if (triggerStates) {\n      const players = [];\n      triggerStates.forEach((state, triggerName) => {\n        previousTriggersValues.set(triggerName, state.value);\n        if (this._triggers.has(triggerName)) {\n          const player = this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);\n          if (player) {\n            players.push(player);\n          }\n        }\n      });\n      if (players.length) {\n        this._engine.markElementAsRemoved(this.id, element, true, context, previousTriggersValues);\n        if (destroyAfterComplete) {\n          optimizeGroupPlayer(players).onDone(() => this._engine.processLeaveNode(element));\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n  prepareLeaveAnimationListeners(element) {\n    const listeners = this._elementListeners.get(element);\n    const elementStates = this._engine.statesByElement.get(element);\n    if (listeners && elementStates) {\n      const visitedTriggers = new Set();\n      listeners.forEach(listener => {\n        const triggerName = listener.name;\n        if (visitedTriggers.has(triggerName)) return;\n        visitedTriggers.add(triggerName);\n        const trigger = this._triggers.get(triggerName);\n        const transition = trigger.fallbackTransition;\n        const fromState = elementStates.get(triggerName) || DEFAULT_STATE_VALUE;\n        const toState = new StateValue(VOID_VALUE);\n        const player = new TransitionAnimationPlayer(this.id, triggerName, element);\n        this._engine.totalQueuedPlayers++;\n        this._queue.push({\n          element,\n          triggerName,\n          transition,\n          fromState,\n          toState,\n          player,\n          isFallbackTransition: true\n        });\n      });\n    }\n  }\n  removeNode(element, context) {\n    const engine = this._engine;\n    if (element.childElementCount) {\n      this._signalRemovalForInnerTriggers(element, context);\n    }\n    if (this.triggerLeaveAnimation(element, context, true)) return;\n    let containsPotentialParentTransition = false;\n    if (engine.totalAnimations) {\n      const currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];\n      if (currentPlayers && currentPlayers.length) {\n        containsPotentialParentTransition = true;\n      } else {\n        let parent = element;\n        while (parent = parent.parentNode) {\n          const triggers = engine.statesByElement.get(parent);\n          if (triggers) {\n            containsPotentialParentTransition = true;\n            break;\n          }\n        }\n      }\n    }\n    this.prepareLeaveAnimationListeners(element);\n    if (containsPotentialParentTransition) {\n      engine.markElementAsRemoved(this.id, element, false, context);\n    } else {\n      const removalFlag = element[REMOVAL_FLAG];\n      if (!removalFlag || removalFlag === NULL_REMOVAL_STATE) {\n        engine.afterFlush(() => this.clearElementCache(element));\n        engine.destroyInnerAnimations(element);\n        engine._onRemovalComplete(element, context);\n      }\n    }\n  }\n  insertNode(element, parent) {\n    addClass(element, this._hostClassName);\n  }\n  drainQueuedTransitions(microtaskId) {\n    const instructions = [];\n    this._queue.forEach(entry => {\n      const player = entry.player;\n      if (player.destroyed) return;\n      const element = entry.element;\n      const listeners = this._elementListeners.get(element);\n      if (listeners) {\n        listeners.forEach(listener => {\n          if (listener.name == entry.triggerName) {\n            const baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);\n            baseEvent['_data'] = microtaskId;\n            listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);\n          }\n        });\n      }\n      if (player.markedForDestroy) {\n        this._engine.afterFlush(() => {\n          player.destroy();\n        });\n      } else {\n        instructions.push(entry);\n      }\n    });\n    this._queue = [];\n    return instructions.sort((a, b) => {\n      const d0 = a.transition.ast.depCount;\n      const d1 = b.transition.ast.depCount;\n      if (d0 == 0 || d1 == 0) {\n        return d0 - d1;\n      }\n      return this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;\n    });\n  }\n  destroy(context) {\n    this.players.forEach(p => p.destroy());\n    this._signalRemovalForInnerTriggers(this.hostElement, context);\n  }\n}\nclass TransitionAnimationEngine {\n  bodyNode;\n  driver;\n  _normalizer;\n  players = [];\n  newHostElements = new Map();\n  playersByElement = new Map();\n  playersByQueriedElement = new Map();\n  statesByElement = new Map();\n  disabledNodes = new Set();\n  totalAnimations = 0;\n  totalQueuedPlayers = 0;\n  _namespaceLookup = {};\n  _namespaceList = [];\n  _flushFns = [];\n  _whenQuietFns = [];\n  namespacesByHostElement = new Map();\n  collectedEnterElements = [];\n  collectedLeaveElements = [];\n  onRemovalComplete = (element, context) => {};\n  _onRemovalComplete(element, context) {\n    this.onRemovalComplete(element, context);\n  }\n  constructor(bodyNode, driver, _normalizer) {\n    this.bodyNode = bodyNode;\n    this.driver = driver;\n    this._normalizer = _normalizer;\n  }\n  get queuedPlayers() {\n    const players = [];\n    this._namespaceList.forEach(ns => {\n      ns.players.forEach(player => {\n        if (player.queued) {\n          players.push(player);\n        }\n      });\n    });\n    return players;\n  }\n  createNamespace(namespaceId, hostElement) {\n    const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);\n    if (this.bodyNode && this.driver.containsElement(this.bodyNode, hostElement)) {\n      this._balanceNamespaceList(ns, hostElement);\n    } else {\n      this.newHostElements.set(hostElement, ns);\n      this.collectEnterElement(hostElement);\n    }\n    return this._namespaceLookup[namespaceId] = ns;\n  }\n  _balanceNamespaceList(ns, hostElement) {\n    const namespaceList = this._namespaceList;\n    const namespacesByHostElement = this.namespacesByHostElement;\n    const limit = namespaceList.length - 1;\n    if (limit >= 0) {\n      let found = false;\n      let ancestor = this.driver.getParentElement(hostElement);\n      while (ancestor) {\n        const ancestorNs = namespacesByHostElement.get(ancestor);\n        if (ancestorNs) {\n          const index = namespaceList.indexOf(ancestorNs);\n          namespaceList.splice(index + 1, 0, ns);\n          found = true;\n          break;\n        }\n        ancestor = this.driver.getParentElement(ancestor);\n      }\n      if (!found) {\n        namespaceList.unshift(ns);\n      }\n    } else {\n      namespaceList.push(ns);\n    }\n    namespacesByHostElement.set(hostElement, ns);\n    return ns;\n  }\n  register(namespaceId, hostElement) {\n    let ns = this._namespaceLookup[namespaceId];\n    if (!ns) {\n      ns = this.createNamespace(namespaceId, hostElement);\n    }\n    return ns;\n  }\n  registerTrigger(namespaceId, name, trigger) {\n    let ns = this._namespaceLookup[namespaceId];\n    if (ns && ns.register(name, trigger)) {\n      this.totalAnimations++;\n    }\n  }\n  destroy(namespaceId, context) {\n    if (!namespaceId) return;\n    this.afterFlush(() => {});\n    this.afterFlushAnimationsDone(() => {\n      const ns = this._fetchNamespace(namespaceId);\n      this.namespacesByHostElement.delete(ns.hostElement);\n      const index = this._namespaceList.indexOf(ns);\n      if (index >= 0) {\n        this._namespaceList.splice(index, 1);\n      }\n      ns.destroy(context);\n      delete this._namespaceLookup[namespaceId];\n    });\n  }\n  _fetchNamespace(id) {\n    return this._namespaceLookup[id];\n  }\n  fetchNamespacesByElement(element) {\n    const namespaces = new Set();\n    const elementStates = this.statesByElement.get(element);\n    if (elementStates) {\n      for (let stateValue of elementStates.values()) {\n        if (stateValue.namespaceId) {\n          const ns = this._fetchNamespace(stateValue.namespaceId);\n          if (ns) {\n            namespaces.add(ns);\n          }\n        }\n      }\n    }\n    return namespaces;\n  }\n  trigger(namespaceId, element, name, value) {\n    if (isElementNode(element)) {\n      const ns = this._fetchNamespace(namespaceId);\n      if (ns) {\n        ns.trigger(element, name, value);\n        return true;\n      }\n    }\n    return false;\n  }\n  insertNode(namespaceId, element, parent, insertBefore) {\n    if (!isElementNode(element)) return;\n    const details = element[REMOVAL_FLAG];\n    if (details && details.setForRemoval) {\n      details.setForRemoval = false;\n      details.setForMove = true;\n      const index = this.collectedLeaveElements.indexOf(element);\n      if (index >= 0) {\n        this.collectedLeaveElements.splice(index, 1);\n      }\n    }\n    if (namespaceId) {\n      const ns = this._fetchNamespace(namespaceId);\n      if (ns) {\n        ns.insertNode(element, parent);\n      }\n    }\n    if (insertBefore) {\n      this.collectEnterElement(element);\n    }\n  }\n  collectEnterElement(element) {\n    this.collectedEnterElements.push(element);\n  }\n  markElementAsDisabled(element, value) {\n    if (value) {\n      if (!this.disabledNodes.has(element)) {\n        this.disabledNodes.add(element);\n        addClass(element, DISABLED_CLASSNAME);\n      }\n    } else if (this.disabledNodes.has(element)) {\n      this.disabledNodes.delete(element);\n      removeClass(element, DISABLED_CLASSNAME);\n    }\n  }\n  removeNode(namespaceId, element, context) {\n    if (isElementNode(element)) {\n      const ns = namespaceId ? this._fetchNamespace(namespaceId) : null;\n      if (ns) {\n        ns.removeNode(element, context);\n      } else {\n        this.markElementAsRemoved(namespaceId, element, false, context);\n      }\n      const hostNS = this.namespacesByHostElement.get(element);\n      if (hostNS && hostNS.id !== namespaceId) {\n        hostNS.removeNode(element, context);\n      }\n    } else {\n      this._onRemovalComplete(element, context);\n    }\n  }\n  markElementAsRemoved(namespaceId, element, hasAnimation, context, previousTriggersValues) {\n    this.collectedLeaveElements.push(element);\n    element[REMOVAL_FLAG] = {\n      namespaceId,\n      setForRemoval: context,\n      hasAnimation,\n      removedBeforeQueried: false,\n      previousTriggersValues\n    };\n  }\n  listen(namespaceId, element, name, phase, callback) {\n    if (isElementNode(element)) {\n      return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);\n    }\n    return () => {};\n  }\n  _buildInstruction(entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {\n    return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);\n  }\n  destroyInnerAnimations(containerElement) {\n    let elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);\n    elements.forEach(element => this.destroyActiveAnimationsForElement(element));\n    if (this.playersByQueriedElement.size == 0) return;\n    elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);\n    elements.forEach(element => this.finishActiveQueriedAnimationOnElement(element));\n  }\n  destroyActiveAnimationsForElement(element) {\n    const players = this.playersByElement.get(element);\n    if (players) {\n      players.forEach(player => {\n        if (player.queued) {\n          player.markedForDestroy = true;\n        } else {\n          player.destroy();\n        }\n      });\n    }\n  }\n  finishActiveQueriedAnimationOnElement(element) {\n    const players = this.playersByQueriedElement.get(element);\n    if (players) {\n      players.forEach(player => player.finish());\n    }\n  }\n  whenRenderingDone() {\n    return new Promise(resolve => {\n      if (this.players.length) {\n        return optimizeGroupPlayer(this.players).onDone(() => resolve());\n      } else {\n        resolve();\n      }\n    });\n  }\n  processLeaveNode(element) {\n    const details = element[REMOVAL_FLAG];\n    if (details && details.setForRemoval) {\n      element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;\n      if (details.namespaceId) {\n        this.destroyInnerAnimations(element);\n        const ns = this._fetchNamespace(details.namespaceId);\n        if (ns) {\n          ns.clearElementCache(element);\n        }\n      }\n      this._onRemovalComplete(element, details.setForRemoval);\n    }\n    if (element.classList?.contains(DISABLED_CLASSNAME)) {\n      this.markElementAsDisabled(element, false);\n    }\n    this.driver.query(element, DISABLED_SELECTOR, true).forEach(node => {\n      this.markElementAsDisabled(node, false);\n    });\n  }\n  flush(microtaskId = -1) {\n    let players = [];\n    if (this.newHostElements.size) {\n      this.newHostElements.forEach((ns, element) => this._balanceNamespaceList(ns, element));\n      this.newHostElements.clear();\n    }\n    if (this.totalAnimations && this.collectedEnterElements.length) {\n      for (let i = 0; i < this.collectedEnterElements.length; i++) {\n        const elm = this.collectedEnterElements[i];\n        addClass(elm, STAR_CLASSNAME);\n      }\n    }\n    if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {\n      const cleanupFns = [];\n      try {\n        players = this._flushAnimations(cleanupFns, microtaskId);\n      } finally {\n        for (let i = 0; i < cleanupFns.length; i++) {\n          cleanupFns[i]();\n        }\n      }\n    } else {\n      for (let i = 0; i < this.collectedLeaveElements.length; i++) {\n        const element = this.collectedLeaveElements[i];\n        this.processLeaveNode(element);\n      }\n    }\n    this.totalQueuedPlayers = 0;\n    this.collectedEnterElements.length = 0;\n    this.collectedLeaveElements.length = 0;\n    this._flushFns.forEach(fn => fn());\n    this._flushFns = [];\n    if (this._whenQuietFns.length) {\n      const quietFns = this._whenQuietFns;\n      this._whenQuietFns = [];\n      if (players.length) {\n        optimizeGroupPlayer(players).onDone(() => {\n          quietFns.forEach(fn => fn());\n        });\n      } else {\n        quietFns.forEach(fn => fn());\n      }\n    }\n  }\n  reportError(errors) {\n    throw triggerTransitionsFailed(errors);\n  }\n  _flushAnimations(cleanupFns, microtaskId) {\n    const subTimelines = new ElementInstructionMap();\n    const skippedPlayers = [];\n    const skippedPlayersMap = new Map();\n    const queuedInstructions = [];\n    const queriedElements = new Map();\n    const allPreStyleElements = new Map();\n    const allPostStyleElements = new Map();\n    const disabledElementsSet = new Set();\n    this.disabledNodes.forEach(node => {\n      disabledElementsSet.add(node);\n      const nodesThatAreDisabled = this.driver.query(node, QUEUED_SELECTOR, true);\n      for (let i = 0; i < nodesThatAreDisabled.length; i++) {\n        disabledElementsSet.add(nodesThatAreDisabled[i]);\n      }\n    });\n    const bodyNode = this.bodyNode;\n    const allTriggerElements = Array.from(this.statesByElement.keys());\n    const enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);\n    const enterNodeMapIds = new Map();\n    let i = 0;\n    enterNodeMap.forEach((nodes, root) => {\n      const className = ENTER_CLASSNAME + i++;\n      enterNodeMapIds.set(root, className);\n      nodes.forEach(node => addClass(node, className));\n    });\n    const allLeaveNodes = [];\n    const mergedLeaveNodes = new Set();\n    const leaveNodesWithoutAnimations = new Set();\n    for (let i = 0; i < this.collectedLeaveElements.length; i++) {\n      const element = this.collectedLeaveElements[i];\n      const details = element[REMOVAL_FLAG];\n      if (details && details.setForRemoval) {\n        allLeaveNodes.push(element);\n        mergedLeaveNodes.add(element);\n        if (details.hasAnimation) {\n          this.driver.query(element, STAR_SELECTOR, true).forEach(elm => mergedLeaveNodes.add(elm));\n        } else {\n          leaveNodesWithoutAnimations.add(element);\n        }\n      }\n    }\n    const leaveNodeMapIds = new Map();\n    const leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));\n    leaveNodeMap.forEach((nodes, root) => {\n      const className = LEAVE_CLASSNAME + i++;\n      leaveNodeMapIds.set(root, className);\n      nodes.forEach(node => addClass(node, className));\n    });\n    cleanupFns.push(() => {\n      enterNodeMap.forEach((nodes, root) => {\n        const className = enterNodeMapIds.get(root);\n        nodes.forEach(node => removeClass(node, className));\n      });\n      leaveNodeMap.forEach((nodes, root) => {\n        const className = leaveNodeMapIds.get(root);\n        nodes.forEach(node => removeClass(node, className));\n      });\n      allLeaveNodes.forEach(element => {\n        this.processLeaveNode(element);\n      });\n    });\n    const allPlayers = [];\n    const erroneousTransitions = [];\n    for (let i = this._namespaceList.length - 1; i >= 0; i--) {\n      const ns = this._namespaceList[i];\n      ns.drainQueuedTransitions(microtaskId).forEach(entry => {\n        const player = entry.player;\n        const element = entry.element;\n        allPlayers.push(player);\n        if (this.collectedEnterElements.length) {\n          const details = element[REMOVAL_FLAG];\n          if (details && details.setForMove) {\n            if (details.previousTriggersValues && details.previousTriggersValues.has(entry.triggerName)) {\n              const previousValue = details.previousTriggersValues.get(entry.triggerName);\n              const triggersWithStates = this.statesByElement.get(entry.element);\n              if (triggersWithStates && triggersWithStates.has(entry.triggerName)) {\n                const state = triggersWithStates.get(entry.triggerName);\n                state.value = previousValue;\n                triggersWithStates.set(entry.triggerName, state);\n              }\n            }\n            player.destroy();\n            return;\n          }\n        }\n        const nodeIsOrphaned = !bodyNode || !this.driver.containsElement(bodyNode, element);\n        const leaveClassName = leaveNodeMapIds.get(element);\n        const enterClassName = enterNodeMapIds.get(element);\n        const instruction = this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned);\n        if (instruction.errors && instruction.errors.length) {\n          erroneousTransitions.push(instruction);\n          return;\n        }\n        if (nodeIsOrphaned) {\n          player.onStart(() => eraseStyles(element, instruction.fromStyles));\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          skippedPlayers.push(player);\n          return;\n        }\n        if (entry.isFallbackTransition) {\n          player.onStart(() => eraseStyles(element, instruction.fromStyles));\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          skippedPlayers.push(player);\n          return;\n        }\n        const timelines = [];\n        instruction.timelines.forEach(tl => {\n          tl.stretchStartingKeyframe = true;\n          if (!this.disabledNodes.has(tl.element)) {\n            timelines.push(tl);\n          }\n        });\n        instruction.timelines = timelines;\n        subTimelines.append(element, instruction.timelines);\n        const tuple = {\n          instruction,\n          player,\n          element\n        };\n        queuedInstructions.push(tuple);\n        instruction.queriedElements.forEach(element => getOrSetDefaultValue(queriedElements, element, []).push(player));\n        instruction.preStyleProps.forEach((stringMap, element) => {\n          if (stringMap.size) {\n            let setVal = allPreStyleElements.get(element);\n            if (!setVal) {\n              allPreStyleElements.set(element, setVal = new Set());\n            }\n            stringMap.forEach((_, prop) => setVal.add(prop));\n          }\n        });\n        instruction.postStyleProps.forEach((stringMap, element) => {\n          let setVal = allPostStyleElements.get(element);\n          if (!setVal) {\n            allPostStyleElements.set(element, setVal = new Set());\n          }\n          stringMap.forEach((_, prop) => setVal.add(prop));\n        });\n      });\n    }\n    if (erroneousTransitions.length) {\n      const errors = [];\n      erroneousTransitions.forEach(instruction => {\n        errors.push(transitionFailed(instruction.triggerName, instruction.errors));\n      });\n      allPlayers.forEach(player => player.destroy());\n      this.reportError(errors);\n    }\n    const allPreviousPlayersMap = new Map();\n    const animationElementMap = new Map();\n    queuedInstructions.forEach(entry => {\n      const element = entry.element;\n      if (subTimelines.has(element)) {\n        animationElementMap.set(element, element);\n        this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);\n      }\n    });\n    skippedPlayers.forEach(player => {\n      const element = player.element;\n      const previousPlayers = this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);\n      previousPlayers.forEach(prevPlayer => {\n        getOrSetDefaultValue(allPreviousPlayersMap, element, []).push(prevPlayer);\n        prevPlayer.destroy();\n      });\n    });\n    const replaceNodes = allLeaveNodes.filter(node => {\n      return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);\n    });\n    const postStylesMap = new Map();\n    const allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, AUTO_STYLE);\n    allLeaveQueriedNodes.forEach(node => {\n      if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {\n        replaceNodes.push(node);\n      }\n    });\n    const preStylesMap = new Map();\n    enterNodeMap.forEach((nodes, root) => {\n      cloakAndComputeStyles(preStylesMap, this.driver, new Set(nodes), allPreStyleElements, _PRE_STYLE);\n    });\n    replaceNodes.forEach(node => {\n      const post = postStylesMap.get(node);\n      const pre = preStylesMap.get(node);\n      postStylesMap.set(node, new Map([...(post?.entries() ?? []), ...(pre?.entries() ?? [])]));\n    });\n    const rootPlayers = [];\n    const subPlayers = [];\n    const NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};\n    queuedInstructions.forEach(entry => {\n      const {\n        element,\n        player,\n        instruction\n      } = entry;\n      if (subTimelines.has(element)) {\n        if (disabledElementsSet.has(element)) {\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          player.disabled = true;\n          player.overrideTotalTime(instruction.totalTime);\n          skippedPlayers.push(player);\n          return;\n        }\n        let parentWithAnimation = NO_PARENT_ANIMATION_ELEMENT_DETECTED;\n        if (animationElementMap.size > 1) {\n          let elm = element;\n          const parentsToAdd = [];\n          while (elm = elm.parentNode) {\n            const detectedParent = animationElementMap.get(elm);\n            if (detectedParent) {\n              parentWithAnimation = detectedParent;\n              break;\n            }\n            parentsToAdd.push(elm);\n          }\n          parentsToAdd.forEach(parent => animationElementMap.set(parent, parentWithAnimation));\n        }\n        const innerPlayer = this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);\n        player.setRealPlayer(innerPlayer);\n        if (parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {\n          rootPlayers.push(player);\n        } else {\n          const parentPlayers = this.playersByElement.get(parentWithAnimation);\n          if (parentPlayers && parentPlayers.length) {\n            player.parentPlayer = optimizeGroupPlayer(parentPlayers);\n          }\n          skippedPlayers.push(player);\n        }\n      } else {\n        eraseStyles(element, instruction.fromStyles);\n        player.onDestroy(() => setStyles(element, instruction.toStyles));\n        subPlayers.push(player);\n        if (disabledElementsSet.has(element)) {\n          skippedPlayers.push(player);\n        }\n      }\n    });\n    subPlayers.forEach(player => {\n      const playersForElement = skippedPlayersMap.get(player.element);\n      if (playersForElement && playersForElement.length) {\n        const innerPlayer = optimizeGroupPlayer(playersForElement);\n        player.setRealPlayer(innerPlayer);\n      }\n    });\n    skippedPlayers.forEach(player => {\n      if (player.parentPlayer) {\n        player.syncPlayerEvents(player.parentPlayer);\n      } else {\n        player.destroy();\n      }\n    });\n    for (let i = 0; i < allLeaveNodes.length; i++) {\n      const element = allLeaveNodes[i];\n      const details = element[REMOVAL_FLAG];\n      removeClass(element, LEAVE_CLASSNAME);\n      if (details && details.hasAnimation) continue;\n      let players = [];\n      if (queriedElements.size) {\n        let queriedPlayerResults = queriedElements.get(element);\n        if (queriedPlayerResults && queriedPlayerResults.length) {\n          players.push(...queriedPlayerResults);\n        }\n        let queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);\n        for (let j = 0; j < queriedInnerElements.length; j++) {\n          let queriedPlayers = queriedElements.get(queriedInnerElements[j]);\n          if (queriedPlayers && queriedPlayers.length) {\n            players.push(...queriedPlayers);\n          }\n        }\n      }\n      const activePlayers = players.filter(p => !p.destroyed);\n      if (activePlayers.length) {\n        removeNodesAfterAnimationDone(this, element, activePlayers);\n      } else {\n        this.processLeaveNode(element);\n      }\n    }\n    allLeaveNodes.length = 0;\n    rootPlayers.forEach(player => {\n      this.players.push(player);\n      player.onDone(() => {\n        player.destroy();\n        const index = this.players.indexOf(player);\n        this.players.splice(index, 1);\n      });\n      player.play();\n    });\n    return rootPlayers;\n  }\n  afterFlush(callback) {\n    this._flushFns.push(callback);\n  }\n  afterFlushAnimationsDone(callback) {\n    this._whenQuietFns.push(callback);\n  }\n  _getPreviousPlayers(element, isQueriedElement, namespaceId, triggerName, toStateValue) {\n    let players = [];\n    if (isQueriedElement) {\n      const queriedElementPlayers = this.playersByQueriedElement.get(element);\n      if (queriedElementPlayers) {\n        players = queriedElementPlayers;\n      }\n    } else {\n      const elementPlayers = this.playersByElement.get(element);\n      if (elementPlayers) {\n        const isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;\n        elementPlayers.forEach(player => {\n          if (player.queued) return;\n          if (!isRemovalAnimation && player.triggerName != triggerName) return;\n          players.push(player);\n        });\n      }\n    }\n    if (namespaceId || triggerName) {\n      players = players.filter(player => {\n        if (namespaceId && namespaceId != player.namespaceId) return false;\n        if (triggerName && triggerName != player.triggerName) return false;\n        return true;\n      });\n    }\n    return players;\n  }\n  _beforeAnimationBuild(namespaceId, instruction, allPreviousPlayersMap) {\n    const triggerName = instruction.triggerName;\n    const rootElement = instruction.element;\n    const targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;\n    const targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;\n    for (const timelineInstruction of instruction.timelines) {\n      const element = timelineInstruction.element;\n      const isQueriedElement = element !== rootElement;\n      const players = getOrSetDefaultValue(allPreviousPlayersMap, element, []);\n      const previousPlayers = this._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);\n      previousPlayers.forEach(player => {\n        const realPlayer = player.getRealPlayer();\n        if (realPlayer.beforeDestroy) {\n          realPlayer.beforeDestroy();\n        }\n        player.destroy();\n        players.push(player);\n      });\n    }\n    eraseStyles(rootElement, instruction.fromStyles);\n  }\n  _buildAnimation(namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {\n    const triggerName = instruction.triggerName;\n    const rootElement = instruction.element;\n    const allQueriedPlayers = [];\n    const allConsumedElements = new Set();\n    const allSubElements = new Set();\n    const allNewPlayers = instruction.timelines.map(timelineInstruction => {\n      const element = timelineInstruction.element;\n      allConsumedElements.add(element);\n      const details = element[REMOVAL_FLAG];\n      if (details && details.removedBeforeQueried) return new NoopAnimationPlayer(timelineInstruction.duration, timelineInstruction.delay);\n      const isQueriedElement = element !== rootElement;\n      const previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY).map(p => p.getRealPlayer())).filter(p => {\n        const pp = p;\n        return pp.element ? pp.element === element : false;\n      });\n      const preStyles = preStylesMap.get(element);\n      const postStyles = postStylesMap.get(element);\n      const keyframes = normalizeKeyframes(this._normalizer, timelineInstruction.keyframes, preStyles, postStyles);\n      const player = this._buildPlayer(timelineInstruction, keyframes, previousPlayers);\n      if (timelineInstruction.subTimeline && skippedPlayersMap) {\n        allSubElements.add(element);\n      }\n      if (isQueriedElement) {\n        const wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);\n        wrappedPlayer.setRealPlayer(player);\n        allQueriedPlayers.push(wrappedPlayer);\n      }\n      return player;\n    });\n    allQueriedPlayers.forEach(player => {\n      getOrSetDefaultValue(this.playersByQueriedElement, player.element, []).push(player);\n      player.onDone(() => deleteOrUnsetInMap(this.playersByQueriedElement, player.element, player));\n    });\n    allConsumedElements.forEach(element => addClass(element, NG_ANIMATING_CLASSNAME));\n    const player = optimizeGroupPlayer(allNewPlayers);\n    player.onDestroy(() => {\n      allConsumedElements.forEach(element => removeClass(element, NG_ANIMATING_CLASSNAME));\n      setStyles(rootElement, instruction.toStyles);\n    });\n    allSubElements.forEach(element => {\n      getOrSetDefaultValue(skippedPlayersMap, element, []).push(player);\n    });\n    return player;\n  }\n  _buildPlayer(instruction, keyframes, previousPlayers) {\n    if (keyframes.length > 0) {\n      return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);\n    }\n    return new NoopAnimationPlayer(instruction.duration, instruction.delay);\n  }\n}\nclass TransitionAnimationPlayer {\n  namespaceId;\n  triggerName;\n  element;\n  _player = new NoopAnimationPlayer();\n  _containsRealPlayer = false;\n  _queuedCallbacks = new Map();\n  destroyed = false;\n  parentPlayer = null;\n  markedForDestroy = false;\n  disabled = false;\n  queued = true;\n  totalTime = 0;\n  constructor(namespaceId, triggerName, element) {\n    this.namespaceId = namespaceId;\n    this.triggerName = triggerName;\n    this.element = element;\n  }\n  setRealPlayer(player) {\n    if (this._containsRealPlayer) return;\n    this._player = player;\n    this._queuedCallbacks.forEach((callbacks, phase) => {\n      callbacks.forEach(callback => listenOnPlayer(player, phase, undefined, callback));\n    });\n    this._queuedCallbacks.clear();\n    this._containsRealPlayer = true;\n    this.overrideTotalTime(player.totalTime);\n    this.queued = false;\n  }\n  getRealPlayer() {\n    return this._player;\n  }\n  overrideTotalTime(totalTime) {\n    this.totalTime = totalTime;\n  }\n  syncPlayerEvents(player) {\n    const p = this._player;\n    if (p.triggerCallback) {\n      player.onStart(() => p.triggerCallback('start'));\n    }\n    player.onDone(() => this.finish());\n    player.onDestroy(() => this.destroy());\n  }\n  _queueEvent(name, callback) {\n    getOrSetDefaultValue(this._queuedCallbacks, name, []).push(callback);\n  }\n  onDone(fn) {\n    if (this.queued) {\n      this._queueEvent('done', fn);\n    }\n    this._player.onDone(fn);\n  }\n  onStart(fn) {\n    if (this.queued) {\n      this._queueEvent('start', fn);\n    }\n    this._player.onStart(fn);\n  }\n  onDestroy(fn) {\n    if (this.queued) {\n      this._queueEvent('destroy', fn);\n    }\n    this._player.onDestroy(fn);\n  }\n  init() {\n    this._player.init();\n  }\n  hasStarted() {\n    return this.queued ? false : this._player.hasStarted();\n  }\n  play() {\n    !this.queued && this._player.play();\n  }\n  pause() {\n    !this.queued && this._player.pause();\n  }\n  restart() {\n    !this.queued && this._player.restart();\n  }\n  finish() {\n    this._player.finish();\n  }\n  destroy() {\n    this.destroyed = true;\n    this._player.destroy();\n  }\n  reset() {\n    !this.queued && this._player.reset();\n  }\n  setPosition(p) {\n    if (!this.queued) {\n      this._player.setPosition(p);\n    }\n  }\n  getPosition() {\n    return this.queued ? 0 : this._player.getPosition();\n  }\n  triggerCallback(phaseName) {\n    const p = this._player;\n    if (p.triggerCallback) {\n      p.triggerCallback(phaseName);\n    }\n  }\n}\nfunction deleteOrUnsetInMap(map, key, value) {\n  let currentValues = map.get(key);\n  if (currentValues) {\n    if (currentValues.length) {\n      const index = currentValues.indexOf(value);\n      currentValues.splice(index, 1);\n    }\n    if (currentValues.length == 0) {\n      map.delete(key);\n    }\n  }\n  return currentValues;\n}\nfunction normalizeTriggerValue(value) {\n  return value != null ? value : null;\n}\nfunction isElementNode(node) {\n  return node && node['nodeType'] === 1;\n}\nfunction isTriggerEventValid(eventName) {\n  return eventName == 'start' || eventName == 'done';\n}\nfunction cloakElement(element, value) {\n  const oldValue = element.style.display;\n  element.style.display = value != null ? value : 'none';\n  return oldValue;\n}\nfunction cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {\n  const cloakVals = [];\n  elements.forEach(element => cloakVals.push(cloakElement(element)));\n  const failedElements = [];\n  elementPropsMap.forEach((props, element) => {\n    const styles = new Map();\n    props.forEach(prop => {\n      const value = driver.computeStyle(element, prop, defaultStyle);\n      styles.set(prop, value);\n      if (!value || value.length == 0) {\n        element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;\n        failedElements.push(element);\n      }\n    });\n    valuesMap.set(element, styles);\n  });\n  let i = 0;\n  elements.forEach(element => cloakElement(element, cloakVals[i++]));\n  return failedElements;\n}\nfunction buildRootMap(roots, nodes) {\n  const rootMap = new Map();\n  roots.forEach(root => rootMap.set(root, []));\n  if (nodes.length == 0) return rootMap;\n  const NULL_NODE = 1;\n  const nodeSet = new Set(nodes);\n  const localRootMap = new Map();\n  function getRoot(node) {\n    if (!node) return NULL_NODE;\n    let root = localRootMap.get(node);\n    if (root) return root;\n    const parent = node.parentNode;\n    if (rootMap.has(parent)) {\n      root = parent;\n    } else if (nodeSet.has(parent)) {\n      root = NULL_NODE;\n    } else {\n      root = getRoot(parent);\n    }\n    localRootMap.set(node, root);\n    return root;\n  }\n  nodes.forEach(node => {\n    const root = getRoot(node);\n    if (root !== NULL_NODE) {\n      rootMap.get(root).push(node);\n    }\n  });\n  return rootMap;\n}\nfunction addClass(element, className) {\n  element.classList?.add(className);\n}\nfunction removeClass(element, className) {\n  element.classList?.remove(className);\n}\nfunction removeNodesAfterAnimationDone(engine, element, players) {\n  optimizeGroupPlayer(players).onDone(() => engine.processLeaveNode(element));\n}\nfunction flattenGroupPlayers(players) {\n  const finalPlayers = [];\n  _flattenGroupPlayersRecur(players, finalPlayers);\n  return finalPlayers;\n}\nfunction _flattenGroupPlayersRecur(players, finalPlayers) {\n  for (let i = 0; i < players.length; i++) {\n    const player = players[i];\n    if (player instanceof AnimationGroupPlayer) {\n      _flattenGroupPlayersRecur(player.players, finalPlayers);\n    } else {\n      finalPlayers.push(player);\n    }\n  }\n}\nfunction objEquals(a, b) {\n  const k1 = Object.keys(a);\n  const k2 = Object.keys(b);\n  if (k1.length != k2.length) return false;\n  for (let i = 0; i < k1.length; i++) {\n    const prop = k1[i];\n    if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return false;\n  }\n  return true;\n}\nfunction replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {\n  const postEntry = allPostStyleElements.get(element);\n  if (!postEntry) return false;\n  let preEntry = allPreStyleElements.get(element);\n  if (preEntry) {\n    postEntry.forEach(data => preEntry.add(data));\n  } else {\n    allPreStyleElements.set(element, postEntry);\n  }\n  allPostStyleElements.delete(element);\n  return true;\n}\nclass AnimationEngine {\n  _driver;\n  _normalizer;\n  _transitionEngine;\n  _timelineEngine;\n  _triggerCache = {};\n  onRemovalComplete = (element, context) => {};\n  constructor(doc, _driver, _normalizer) {\n    this._driver = _driver;\n    this._normalizer = _normalizer;\n    this._transitionEngine = new TransitionAnimationEngine(doc.body, _driver, _normalizer);\n    this._timelineEngine = new TimelineAnimationEngine(doc.body, _driver, _normalizer);\n    this._transitionEngine.onRemovalComplete = (element, context) => this.onRemovalComplete(element, context);\n  }\n  registerTrigger(componentId, namespaceId, hostElement, name, metadata) {\n    const cacheKey = componentId + '-' + name;\n    let trigger = this._triggerCache[cacheKey];\n    if (!trigger) {\n      const errors = [];\n      const warnings = [];\n      const ast = buildAnimationAst(this._driver, metadata, errors, warnings);\n      if (errors.length) {\n        throw triggerBuildFailed(name, errors);\n      }\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (warnings.length) {\n          warnTriggerBuild(name, warnings);\n        }\n      }\n      trigger = buildTrigger(name, ast, this._normalizer);\n      this._triggerCache[cacheKey] = trigger;\n    }\n    this._transitionEngine.registerTrigger(namespaceId, name, trigger);\n  }\n  register(namespaceId, hostElement) {\n    this._transitionEngine.register(namespaceId, hostElement);\n  }\n  destroy(namespaceId, context) {\n    this._transitionEngine.destroy(namespaceId, context);\n  }\n  onInsert(namespaceId, element, parent, insertBefore) {\n    this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);\n  }\n  onRemove(namespaceId, element, context) {\n    this._transitionEngine.removeNode(namespaceId, element, context);\n  }\n  disableAnimations(element, disable) {\n    this._transitionEngine.markElementAsDisabled(element, disable);\n  }\n  process(namespaceId, element, property, value) {\n    if (property.charAt(0) == '@') {\n      const [id, action] = parseTimelineCommand(property);\n      const args = value;\n      this._timelineEngine.command(id, element, action, args);\n    } else {\n      this._transitionEngine.trigger(namespaceId, element, property, value);\n    }\n  }\n  listen(namespaceId, element, eventName, eventPhase, callback) {\n    if (eventName.charAt(0) == '@') {\n      const [id, action] = parseTimelineCommand(eventName);\n      return this._timelineEngine.listen(id, element, action, callback);\n    }\n    return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);\n  }\n  flush(microtaskId = -1) {\n    this._transitionEngine.flush(microtaskId);\n  }\n  get players() {\n    return [...this._transitionEngine.players, ...this._timelineEngine.players];\n  }\n  whenRenderingDone() {\n    return this._transitionEngine.whenRenderingDone();\n  }\n  afterFlushAnimationsDone(cb) {\n    this._transitionEngine.afterFlushAnimationsDone(cb);\n  }\n}\nfunction packageNonAnimatableStyles(element, styles) {\n  let startStyles = null;\n  let endStyles = null;\n  if (Array.isArray(styles) && styles.length) {\n    startStyles = filterNonAnimatableStyles(styles[0]);\n    if (styles.length > 1) {\n      endStyles = filterNonAnimatableStyles(styles[styles.length - 1]);\n    }\n  } else if (styles instanceof Map) {\n    startStyles = filterNonAnimatableStyles(styles);\n  }\n  return startStyles || endStyles ? new SpecialCasedStyles(element, startStyles, endStyles) : null;\n}\nclass SpecialCasedStyles {\n  _element;\n  _startStyles;\n  _endStyles;\n  static initialStylesByElement = /* @__PURE__ */new WeakMap();\n  _state = 0;\n  _initialStyles;\n  constructor(_element, _startStyles, _endStyles) {\n    this._element = _element;\n    this._startStyles = _startStyles;\n    this._endStyles = _endStyles;\n    let initialStyles = SpecialCasedStyles.initialStylesByElement.get(_element);\n    if (!initialStyles) {\n      SpecialCasedStyles.initialStylesByElement.set(_element, initialStyles = new Map());\n    }\n    this._initialStyles = initialStyles;\n  }\n  start() {\n    if (this._state < 1) {\n      if (this._startStyles) {\n        setStyles(this._element, this._startStyles, this._initialStyles);\n      }\n      this._state = 1;\n    }\n  }\n  finish() {\n    this.start();\n    if (this._state < 2) {\n      setStyles(this._element, this._initialStyles);\n      if (this._endStyles) {\n        setStyles(this._element, this._endStyles);\n        this._endStyles = null;\n      }\n      this._state = 1;\n    }\n  }\n  destroy() {\n    this.finish();\n    if (this._state < 3) {\n      SpecialCasedStyles.initialStylesByElement.delete(this._element);\n      if (this._startStyles) {\n        eraseStyles(this._element, this._startStyles);\n        this._endStyles = null;\n      }\n      if (this._endStyles) {\n        eraseStyles(this._element, this._endStyles);\n        this._endStyles = null;\n      }\n      setStyles(this._element, this._initialStyles);\n      this._state = 3;\n    }\n  }\n}\nfunction filterNonAnimatableStyles(styles) {\n  let result = null;\n  styles.forEach((val, prop) => {\n    if (isNonAnimatableStyle(prop)) {\n      result = result || new Map();\n      result.set(prop, val);\n    }\n  });\n  return result;\n}\nfunction isNonAnimatableStyle(prop) {\n  return prop === 'display' || prop === 'position';\n}\nclass WebAnimationsPlayer {\n  element;\n  keyframes;\n  options;\n  _specialStyles;\n  _onDoneFns = [];\n  _onStartFns = [];\n  _onDestroyFns = [];\n  _duration;\n  _delay;\n  _initialized = false;\n  _finished = false;\n  _started = false;\n  _destroyed = false;\n  _finalKeyframe;\n  _originalOnDoneFns = [];\n  _originalOnStartFns = [];\n  domPlayer = null;\n  time = 0;\n  parentPlayer = null;\n  currentSnapshot = new Map();\n  constructor(element, keyframes, options, _specialStyles) {\n    this.element = element;\n    this.keyframes = keyframes;\n    this.options = options;\n    this._specialStyles = _specialStyles;\n    this._duration = options['duration'];\n    this._delay = options['delay'] || 0;\n    this.time = this._duration + this._delay;\n  }\n  _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n  init() {\n    if (!this._buildPlayer()) {\n      return;\n    }\n    this._preparePlayerBeforeStart();\n  }\n  _buildPlayer() {\n    if (this._initialized) return this.domPlayer;\n    this._initialized = true;\n    const keyframes = this.keyframes;\n    const animation = this._triggerWebAnimation(this.element, keyframes, this.options);\n    if (!animation) {\n      this._onFinish();\n      return null;\n    }\n    this.domPlayer = animation;\n    this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : new Map();\n    const onFinish = () => this._onFinish();\n    animation.addEventListener('finish', onFinish);\n    this.onDestroy(() => {\n      animation.removeEventListener('finish', onFinish);\n    });\n    return animation;\n  }\n  _preparePlayerBeforeStart() {\n    if (this._delay) {\n      this._resetDomPlayerState();\n    } else {\n      this.domPlayer?.pause();\n    }\n  }\n  _convertKeyframesToObject(keyframes) {\n    const kfs = [];\n    keyframes.forEach(frame => {\n      kfs.push(Object.fromEntries(frame));\n    });\n    return kfs;\n  }\n  _triggerWebAnimation(element, keyframes, options) {\n    const keyframesObject = this._convertKeyframesToObject(keyframes);\n    try {\n      return element.animate(keyframesObject, options);\n    } catch {\n      return null;\n    }\n  }\n  onStart(fn) {\n    this._originalOnStartFns.push(fn);\n    this._onStartFns.push(fn);\n  }\n  onDone(fn) {\n    this._originalOnDoneFns.push(fn);\n    this._onDoneFns.push(fn);\n  }\n  onDestroy(fn) {\n    this._onDestroyFns.push(fn);\n  }\n  play() {\n    const player = this._buildPlayer();\n    if (!player) {\n      return;\n    }\n    if (!this.hasStarted()) {\n      this._onStartFns.forEach(fn => fn());\n      this._onStartFns = [];\n      this._started = true;\n      if (this._specialStyles) {\n        this._specialStyles.start();\n      }\n    }\n    player.play();\n  }\n  pause() {\n    this.init();\n    this.domPlayer?.pause();\n  }\n  finish() {\n    this.init();\n    if (!this.domPlayer) return;\n    if (this._specialStyles) {\n      this._specialStyles.finish();\n    }\n    this._onFinish();\n    this.domPlayer.finish();\n  }\n  reset() {\n    this._resetDomPlayerState();\n    this._destroyed = false;\n    this._finished = false;\n    this._started = false;\n    this._onStartFns = this._originalOnStartFns;\n    this._onDoneFns = this._originalOnDoneFns;\n  }\n  _resetDomPlayerState() {\n    this.domPlayer?.cancel();\n  }\n  restart() {\n    this.reset();\n    this.play();\n  }\n  hasStarted() {\n    return this._started;\n  }\n  destroy() {\n    if (!this._destroyed) {\n      this._destroyed = true;\n      this._resetDomPlayerState();\n      this._onFinish();\n      if (this._specialStyles) {\n        this._specialStyles.destroy();\n      }\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n  setPosition(p) {\n    if (!this.domPlayer) {\n      this.init();\n    }\n    if (this.domPlayer) {\n      this.domPlayer.currentTime = p * this.time;\n    }\n  }\n  getPosition() {\n    if (!this.domPlayer) {\n      return this._initialized ? 1 : 0;\n    }\n    return +(this.domPlayer.currentTime ?? 0) / this.time;\n  }\n  get totalTime() {\n    return this._delay + this._duration;\n  }\n  beforeDestroy() {\n    const styles = new Map();\n    if (this.hasStarted()) {\n      const finalKeyframe = this._finalKeyframe;\n      finalKeyframe.forEach((val, prop) => {\n        if (prop !== 'offset') {\n          styles.set(prop, this._finished ? val : computeStyle(this.element, prop));\n        }\n      });\n    }\n    this.currentSnapshot = styles;\n  }\n  triggerCallback(phaseName) {\n    const methods = phaseName === 'start' ? this._onStartFns : this._onDoneFns;\n    methods.forEach(fn => fn());\n    methods.length = 0;\n  }\n}\nclass WebAnimationsDriver {\n  validateStyleProperty(prop) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      return validateStyleProperty(prop);\n    }\n    return true;\n  }\n  validateAnimatableStyleProperty(prop) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const cssProp = camelCaseToDashCase(prop);\n      return validateWebAnimatableStyleProperty(cssProp);\n    }\n    return true;\n  }\n  containsElement(elm1, elm2) {\n    return containsElement(elm1, elm2);\n  }\n  getParentElement(element) {\n    return getParentElement(element);\n  }\n  query(element, selector, multi) {\n    return invokeQuery(element, selector, multi);\n  }\n  computeStyle(element, prop, defaultValue) {\n    return computeStyle(element, prop);\n  }\n  animate(element, keyframes, duration, delay, easing, previousPlayers = []) {\n    const fill = delay == 0 ? 'both' : 'forwards';\n    const playerOptions = {\n      duration,\n      delay,\n      fill\n    };\n    if (easing) {\n      playerOptions['easing'] = easing;\n    }\n    const previousStyles = new Map();\n    const previousWebAnimationPlayers = previousPlayers.filter(player => player instanceof WebAnimationsPlayer);\n    if (allowPreviousPlayerStylesMerge(duration, delay)) {\n      previousWebAnimationPlayers.forEach(player => {\n        player.currentSnapshot.forEach((val, prop) => previousStyles.set(prop, val));\n      });\n    }\n    let _keyframes = normalizeKeyframes$1(keyframes).map(styles => new Map(styles));\n    _keyframes = balancePreviousStylesIntoKeyframes(element, _keyframes, previousStyles);\n    const specialStyles = packageNonAnimatableStyles(element, _keyframes);\n    return new WebAnimationsPlayer(element, _keyframes, playerOptions, specialStyles);\n  }\n}\nfunction createEngine(type, doc) {\n  if (type === 'noop') {\n    return new AnimationEngine(doc, new NoopAnimationDriver(), new NoopAnimationStyleNormalizer());\n  }\n  return new AnimationEngine(doc, new WebAnimationsDriver(), new WebAnimationsStyleNormalizer());\n}\nclass Animation {\n  _driver;\n  _animationAst;\n  constructor(_driver, input) {\n    this._driver = _driver;\n    const errors = [];\n    const warnings = [];\n    const ast = buildAnimationAst(_driver, input, errors, warnings);\n    if (errors.length) {\n      throw validationFailed(errors);\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (warnings.length) {\n        warnValidation(warnings);\n      }\n    }\n    this._animationAst = ast;\n  }\n  buildTimelines(element, startingStyles, destinationStyles, options, subInstructions) {\n    const start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : startingStyles;\n    const dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : destinationStyles;\n    const errors = [];\n    subInstructions = subInstructions || new ElementInstructionMap();\n    const result = buildAnimationTimelines(this._driver, element, this._animationAst, ENTER_CLASSNAME, LEAVE_CLASSNAME, start, dest, options, subInstructions, errors);\n    if (errors.length) {\n      throw buildingFailed(errors);\n    }\n    return result;\n  }\n}\nconst ANIMATION_PREFIX = '@';\nconst DISABLE_ANIMATIONS_FLAG = '@.disabled';\nclass BaseAnimationRenderer {\n  namespaceId;\n  delegate;\n  engine;\n  _onDestroy;\n  ɵtype = 0;\n  constructor(namespaceId, delegate, engine, _onDestroy) {\n    this.namespaceId = namespaceId;\n    this.delegate = delegate;\n    this.engine = engine;\n    this._onDestroy = _onDestroy;\n  }\n  get data() {\n    return this.delegate.data;\n  }\n  destroyNode(node) {\n    this.delegate.destroyNode?.(node);\n  }\n  destroy() {\n    this.engine.destroy(this.namespaceId, this.delegate);\n    this.engine.afterFlushAnimationsDone(() => {\n      queueMicrotask(() => {\n        this.delegate.destroy();\n      });\n    });\n    this._onDestroy?.();\n  }\n  createElement(name, namespace) {\n    return this.delegate.createElement(name, namespace);\n  }\n  createComment(value) {\n    return this.delegate.createComment(value);\n  }\n  createText(value) {\n    return this.delegate.createText(value);\n  }\n  appendChild(parent, newChild) {\n    this.delegate.appendChild(parent, newChild);\n    this.engine.onInsert(this.namespaceId, newChild, parent, false);\n  }\n  insertBefore(parent, newChild, refChild, isMove = true) {\n    this.delegate.insertBefore(parent, newChild, refChild);\n    this.engine.onInsert(this.namespaceId, newChild, parent, isMove);\n  }\n  removeChild(parent, oldChild, isHostElement, requireSynchronousElementRemoval) {\n    if (requireSynchronousElementRemoval) {\n      this.delegate.removeChild(parent, oldChild, isHostElement, requireSynchronousElementRemoval);\n      return;\n    }\n    if (this.parentNode(oldChild)) {\n      this.engine.onRemove(this.namespaceId, oldChild, this.delegate);\n    }\n  }\n  selectRootElement(selectorOrNode, preserveContent) {\n    return this.delegate.selectRootElement(selectorOrNode, preserveContent);\n  }\n  parentNode(node) {\n    return this.delegate.parentNode(node);\n  }\n  nextSibling(node) {\n    return this.delegate.nextSibling(node);\n  }\n  setAttribute(el, name, value, namespace) {\n    this.delegate.setAttribute(el, name, value, namespace);\n  }\n  removeAttribute(el, name, namespace) {\n    this.delegate.removeAttribute(el, name, namespace);\n  }\n  addClass(el, name) {\n    this.delegate.addClass(el, name);\n  }\n  removeClass(el, name) {\n    this.delegate.removeClass(el, name);\n  }\n  setStyle(el, style, value, flags) {\n    this.delegate.setStyle(el, style, value, flags);\n  }\n  removeStyle(el, style, flags) {\n    this.delegate.removeStyle(el, style, flags);\n  }\n  setProperty(el, name, value) {\n    if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {\n      this.disableAnimations(el, !!value);\n    } else {\n      this.delegate.setProperty(el, name, value);\n    }\n  }\n  setValue(node, value) {\n    this.delegate.setValue(node, value);\n  }\n  listen(target, eventName, callback, options) {\n    return this.delegate.listen(target, eventName, callback, options);\n  }\n  disableAnimations(element, value) {\n    this.engine.disableAnimations(element, value);\n  }\n}\nclass AnimationRenderer extends BaseAnimationRenderer {\n  factory;\n  constructor(factory, namespaceId, delegate, engine, onDestroy) {\n    super(namespaceId, delegate, engine, onDestroy);\n    this.factory = factory;\n    this.namespaceId = namespaceId;\n  }\n  setProperty(el, name, value) {\n    if (name.charAt(0) == ANIMATION_PREFIX) {\n      if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {\n        value = value === undefined ? true : !!value;\n        this.disableAnimations(el, value);\n      } else {\n        this.engine.process(this.namespaceId, el, name.slice(1), value);\n      }\n    } else {\n      this.delegate.setProperty(el, name, value);\n    }\n  }\n  listen(target, eventName, callback, options) {\n    if (eventName.charAt(0) == ANIMATION_PREFIX) {\n      const element = resolveElementFromTarget(target);\n      let name = eventName.slice(1);\n      let phase = '';\n      if (name.charAt(0) != ANIMATION_PREFIX) {\n        [name, phase] = parseTriggerCallbackName(name);\n      }\n      return this.engine.listen(this.namespaceId, element, name, phase, event => {\n        const countId = event['_data'] || -1;\n        this.factory.scheduleListenerCallback(countId, callback, event);\n      });\n    }\n    return this.delegate.listen(target, eventName, callback, options);\n  }\n}\nfunction resolveElementFromTarget(target) {\n  switch (target) {\n    case 'body':\n      return document.body;\n    case 'document':\n      return document;\n    case 'window':\n      return window;\n    default:\n      return target;\n  }\n}\nfunction parseTriggerCallbackName(triggerName) {\n  const dotIndex = triggerName.indexOf('.');\n  const trigger = triggerName.substring(0, dotIndex);\n  const phase = triggerName.slice(dotIndex + 1);\n  return [trigger, phase];\n}\nclass AnimationRendererFactory {\n  delegate;\n  engine;\n  _zone;\n  _currentId = 0;\n  _microtaskId = 1;\n  _animationCallbacksBuffer = [];\n  _rendererCache = new Map();\n  _cdRecurDepth = 0;\n  constructor(delegate, engine, _zone) {\n    this.delegate = delegate;\n    this.engine = engine;\n    this._zone = _zone;\n    engine.onRemovalComplete = (element, delegate) => {\n      delegate?.removeChild(null, element);\n    };\n  }\n  createRenderer(hostElement, type) {\n    const EMPTY_NAMESPACE_ID = '';\n    const delegate = this.delegate.createRenderer(hostElement, type);\n    if (!hostElement || !type?.data?.['animation']) {\n      const cache = this._rendererCache;\n      let renderer = cache.get(delegate);\n      if (!renderer) {\n        const onRendererDestroy = () => cache.delete(delegate);\n        renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine, onRendererDestroy);\n        cache.set(delegate, renderer);\n      }\n      return renderer;\n    }\n    const componentId = type.id;\n    const namespaceId = type.id + '-' + this._currentId;\n    this._currentId++;\n    this.engine.register(namespaceId, hostElement);\n    const registerTrigger = trigger => {\n      if (Array.isArray(trigger)) {\n        trigger.forEach(registerTrigger);\n      } else {\n        this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger);\n      }\n    };\n    const animationTriggers = type.data['animation'];\n    animationTriggers.forEach(registerTrigger);\n    return new AnimationRenderer(this, namespaceId, delegate, this.engine);\n  }\n  begin() {\n    this._cdRecurDepth++;\n    if (this.delegate.begin) {\n      this.delegate.begin();\n    }\n  }\n  _scheduleCountTask() {\n    queueMicrotask(() => {\n      this._microtaskId++;\n    });\n  }\n  scheduleListenerCallback(count, fn, data) {\n    if (count >= 0 && count < this._microtaskId) {\n      this._zone.run(() => fn(data));\n      return;\n    }\n    const animationCallbacksBuffer = this._animationCallbacksBuffer;\n    if (animationCallbacksBuffer.length == 0) {\n      queueMicrotask(() => {\n        this._zone.run(() => {\n          animationCallbacksBuffer.forEach(tuple => {\n            const [fn, data] = tuple;\n            fn(data);\n          });\n          this._animationCallbacksBuffer = [];\n        });\n      });\n    }\n    animationCallbacksBuffer.push([fn, data]);\n  }\n  end() {\n    this._cdRecurDepth--;\n    if (this._cdRecurDepth == 0) {\n      this._zone.runOutsideAngular(() => {\n        this._scheduleCountTask();\n        this.engine.flush(this._microtaskId);\n      });\n    }\n    if (this.delegate.end) {\n      this.delegate.end();\n    }\n  }\n  whenRenderingDone() {\n    return this.engine.whenRenderingDone();\n  }\n  componentReplaced(componentId) {\n    this.engine.flush();\n    this.delegate.componentReplaced?.(componentId);\n  }\n}\nexport { AnimationDriver, NoopAnimationDriver, Animation as ɵAnimation, AnimationEngine as ɵAnimationEngine, AnimationRenderer as ɵAnimationRenderer, AnimationRendererFactory as ɵAnimationRendererFactory, AnimationStyleNormalizer as ɵAnimationStyleNormalizer, BaseAnimationRenderer as ɵBaseAnimationRenderer, ENTER_CLASSNAME as ɵENTER_CLASSNAME, LEAVE_CLASSNAME as ɵLEAVE_CLASSNAME, NoopAnimationStyleNormalizer as ɵNoopAnimationStyleNormalizer, TransitionAnimationPlayer as ɵTransitionAnimationPlayer, WebAnimationsDriver as ɵWebAnimationsDriver, WebAnimationsPlayer as ɵWebAnimationsPlayer, WebAnimationsStyleNormalizer as ɵWebAnimationsStyleNormalizer, allowPreviousPlayerStylesMerge as ɵallowPreviousPlayerStylesMerge, camelCaseToDashCase as ɵcamelCaseToDashCase, containsElement as ɵcontainsElement, createEngine as ɵcreateEngine, getParentElement as ɵgetParentElement, invokeQuery as ɵinvokeQuery, normalizeKeyframes$1 as ɵnormalizeKeyframes, validateStyleProperty as ɵvalidateStyleProperty, validateWebAnimatableStyleProperty as ɵvalidateWebAnimatableStyleProperty };","map":{"version":3,"names":["i0","Injectable","validateStyleProperty","containsElement","getParentElement","invokeQuery","dashCaseToCamelCase","invalidCssUnitValue","invalidExpression","invalidTransitionAlias","visitDslNode","invalidTrigger","invalidDefinition","extractStyleParams","invalidState","invalidStyleValue","SUBSTITUTION_EXPR_START","invalidParallelAnimation","validateStyleParams","invalidKeyframes","invalidOffset","keyframeOffsetsOutOfOrder","keyframesMissingOffsets","getOrSetDefaultValue","invalidStagger","resolveTiming","NG_TRIGGER_SELECTOR","NG_ANIMATING_SELECTOR","normalizeAnimationEntry","resolveTimingValue","interpolateParams","invalidQuery","registerFailed","normalizeKeyframes","LEAVE_CLASSNAME","ENTER_CLASSNAME","missingOrDestroyedAnimation","createAnimationFailed","optimizeGroupPlayer","missingPlayer","listenOnPlayer","makeAnimationEvent","triggerTransitionsFailed","eraseStyles","setStyles","transitionFailed","missingTrigger","missingEvent","unsupportedTriggerEvent","NG_TRIGGER_CLASSNAME","unregisteredTrigger","NG_ANIMATING_CLASSNAME","triggerBuildFailed","parseTimelineCommand","computeStyle","camelCaseToDashCase","validateWebAnimatableStyleProperty","allowPreviousPlayerStylesMerge","normalizeKeyframes$1","balancePreviousStylesIntoKeyframes","validationFailed","normalizeStyles","buildingFailed","NoopAnimationPlayer","AnimationMetadataType","style","AUTO_STYLE","ɵPRE_STYLE","_PRE_STYLE","AnimationGroupPlayer","NoopAnimationDriver","prop","elm1","elm2","element","query","selector","multi","defaultValue","animate","keyframes","duration","delay","easing","previousPlayers","scrubberAccessRequested","ɵfac","NoopAnimationDriver_Factory","__ngFactoryType__","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","ɵsetClassMetadata","type","AnimationDriver","NOOP","AnimationStyleNormalizer","NoopAnimationStyleNormalizer","normalizePropertyName","propertyName","errors","normalizeStyleValue","userProvidedProperty","normalizedProperty","value","DIMENSIONAL_PROP_SET","Set","WebAnimationsStyleNormalizer","unit","strVal","toString","trim","has","valAndSuffixMatch","match","length","push","createListOfWarnings","warnings","LINE_START","filter","Boolean","map","warning","join","warnValidation","console","warn","warnTriggerBuild","name","warnRegister","pushUnrecognizedPropertiesWarning","props","ANY_STATE","parseTransitionExpr","transitionValue","expressions","split","forEach","str","parseInnerTransitionStr","eventStr","result","parseAnimationAlias","fromState","separator","toState","makeLambdaFromStates","isFullAnyStateExpr","alias","parseFloat","TRUE_BOOLEAN_VALUES","FALSE_BOOLEAN_VALUES","lhs","rhs","LHS_MATCH_BOOLEAN","RHS_MATCH_BOOLEAN","lhsMatch","rhsMatch","SELF_TOKEN","SELF_TOKEN_REGEX","RegExp","buildAnimationAst","driver","metadata","AnimationAstBuilderVisitor","build","ROOT_SELECTOR","_driver","constructor","context","AnimationAstBuilderContext","_resetContextStyleTimingState","ast","unsupportedCSSPropertiesFound","size","keys","currentQuerySelector","collectedStyles","Map","set","currentTime","visitTrigger","queryCount","depCount","states","transitions","charAt","definitions","def","State","stateDef","n","visitState","Transition","transition","visitTransition","Trigger","options","styleAst","visitStyle","styles","astParams","params","containsDynamicStyles","missingSubs","sub","hasOwnProperty","add","values","animation","matchers","expr","normalizeAnimationOptions","visitSequence","Sequence","steps","s","visitGroup","furthestTime","step","innerAst","Math","max","Group","visitAnimate","timingAst","constructTimingAst","timings","currentAnimateTimings","styleMetadata","Keyframes","visitKeyframes","isEmpty","newStyleData","_styleAst","isEmptyStep","Animate","_makeStyleAst","_validateStyleAst","metadataStyles","Array","isArray","styleTuple","Object","entries","collectedEasing","styleData","get","delete","indexOf","Style","offset","endTime","startTime","tuple","collectedEntry","updateCollectedStyle","MAX_KEYFRAME_OFFSET","totalKeyframesWithOffsets","offsets","offsetsOutOfOrder","keyframesOutOfRange","previousOffset","offsetVal","consumeOffset","generatedOffset","limit","animateDuration","kf","i","durationUpToThisFrame","visitReference","Reference","visitAnimateChild","AnimateChild","visitAnimateRef","AnimateRef","visitQuery","parentSelector","currentQuery","includeSelf","normalizeSelector","Query","optional","originalSelector","visitStagger","Stagger","hasAmpersand","find","replace","slice","normalizeParams","obj","currentTransition","makeTimingAst","strValue","isDynamic","some","v","dynamic","createTimelineInstruction","preStyleProps","postStyleProps","subTimeline","totalTime","ElementInstructionMap","_map","append","instructions","existingInstructions","clear","ONE_FRAME_IN_MILLISECONDS","ENTER_TOKEN","ENTER_TOKEN_REGEX","LEAVE_TOKEN","LEAVE_TOKEN_REGEX","buildAnimationTimelines","rootElement","enterClassName","leaveClassName","startingStyles","finalStyles","subInstructions","AnimationTimelineBuilderVisitor","buildKeyframes","AnimationTimelineContext","currentTimeline","delayNextStep","timelines","timeline","containsAnimation","lastRootTimeline","allowOnlyTimelineStyles","elementInstructions","innerContext","createSubContext","_visitSubInstructions","transformIntoNewTimeline","previousNode","_applyAnimationRefDelays","animationsRefsOptions","animationRefOptions","animationDelay","animationDelayValue","instruction","instructionTimings","appendInstructionToTimeline","updateOptions","subContextCount","ctx","snapshotCurrentStyles","DEFAULT_NOOP_PREVIOUS_NODE","applyStylesToKeyframe","innerTimelines","mergeTimelineCollectedStyles","_visitTiming","timingValue","incrementTime","hasCurrentStyleProperties","forwardFrame","applyEmptyStep","innerTimeline","forwardTime","elms","currentQueryTotal","sameElementTimeline","currentQueryIndex","parentContext","tl","abs","maxTime","staggerTransformer","currentStaggerTime","startingTime","_enterClassName","_leaveClassName","initialTimeline","TimelineBuilder","skipIfExists","newOptions","optionsToUpdate","newParams","paramsToUpdate","_copyOptions","oldParams","newTime","target","fork","updatedTimings","builder","SubTimelineBuilder","stretchStartingKeyframe","time","results","elements","_elementTimelineStylesLookup","_previousKeyframe","_currentKeyframe","_keyframes","_styleSummary","_localTimelineStyles","_globalTimelineStyles","_pendingStyles","_backFill","_currentEmptyStepKeyframe","_loadKeyframe","hasPreStyleStep","_updateStyle","input","flattenStyles","val","getFinalKeyframe","properties","details1","details0","finalKeyframes","keyframe","finalKeyframe","preProps","postProps","kf0","kf1","_stretchStartingKeyframe","newKeyframes","startingGap","newFirstKeyframe","oldFirstKeyframe","roundOffset","oldOffset","timeAtKeyframe","decimalPoints","mult","pow","round","allStyles","allProperties","createTransitionInstruction","triggerName","isRemovalTransition","fromStyles","toStyles","queriedElements","EMPTY_OBJECT","AnimationTransitionFactory","_triggerName","_stateStyles","currentState","nextState","oneOrMoreTransitionsMatch","buildStyles","stateName","styler","undefined","currentOptions","nextOptions","skipAstBuild","transitionAnimationParams","currentAnimationParams","currentStateStyles","nextAnimationParams","nextStateStyles","preStyleMap","postStyleMap","isRemoval","animationOptions","applyParamDefaults","elm","checkNonAnimatableInTimelines","validateAnimatableStyleProperty","allowedNonAnimatableProps","invalidNonAnimatableProps","nonAnimatablePropsInitialValues","entriesToCheck","from","propInitialValue","matchFns","fn","userParams","defaults","key","AnimationStateStyles","defaultParams","normalizer","combinedParams","normalizedProp","buildTrigger","AnimationTrigger","_normalizer","transitionFactories","fallbackTransition","balanceProperties","createFallbackTransition","containsQueries","matchTransition","entry","f","matchStyles","stateMap","key1","key2","EMPTY_INSTRUCTION_MAP","TimelineAnimationEngine","bodyNode","_animations","_playersById","players","register","id","_buildPlayer","preStyles","postStyles","create","autoStylesMap","inst","_","player","onDestroy","destroy","_getPlayer","index","splice","listen","eventName","callback","baseEvent","command","args","play","pause","reset","restart","finish","init","setPosition","QUEUED_CLASSNAME","QUEUED_SELECTOR","DISABLED_CLASSNAME","DISABLED_SELECTOR","STAR_CLASSNAME","STAR_SELECTOR","EMPTY_PLAYER_ARRAY","NULL_REMOVAL_STATE","namespaceId","setForRemoval","setForMove","hasAnimation","removedBeforeQueried","NULL_REMOVED_QUERIED_STATE","REMOVAL_FLAG","StateValue","isObj","normalizeTriggerValue","absorbOptions","VOID_VALUE","DEFAULT_STATE_VALUE","AnimationTransitionNamespace","hostElement","_engine","_triggers","_queue","_elementListeners","_hostClassName","addClass","phase","isTriggerEventValid","listeners","data","triggersWithStates","statesByElement","afterFlush","_getTrigger","trigger","defaultToFallback","TransitionAnimationPlayer","objEquals","reportError","playersOnElement","playersByElement","queued","isFallbackTransition","totalQueuedPlayers","onStart","removeClass","onDone","deregister","clearElementCache","elementPlayers","_signalRemovalForInnerTriggers","namespaces","fetchNamespacesByElement","ns","triggerLeaveAnimation","afterFlushAnimationsDone","destroyAfterComplete","triggerStates","previousTriggersValues","state","markElementAsRemoved","processLeaveNode","prepareLeaveAnimationListeners","elementStates","visitedTriggers","listener","removeNode","engine","childElementCount","containsPotentialParentTransition","totalAnimations","currentPlayers","playersByQueriedElement","parent","parentNode","triggers","removalFlag","destroyInnerAnimations","_onRemovalComplete","insertNode","drainQueuedTransitions","microtaskId","destroyed","markedForDestroy","sort","a","b","d0","d1","p","TransitionAnimationEngine","newHostElements","disabledNodes","_namespaceLookup","_namespaceList","_flushFns","_whenQuietFns","namespacesByHostElement","collectedEnterElements","collectedLeaveElements","onRemovalComplete","queuedPlayers","createNamespace","_balanceNamespaceList","collectEnterElement","namespaceList","found","ancestor","ancestorNs","unshift","registerTrigger","_fetchNamespace","stateValue","isElementNode","insertBefore","details","markElementAsDisabled","hostNS","_buildInstruction","subTimelines","skipBuildAst","containerElement","destroyActiveAnimationsForElement","finishActiveQueriedAnimationOnElement","whenRenderingDone","Promise","resolve","classList","contains","node","flush","cleanupFns","_flushAnimations","quietFns","skippedPlayers","skippedPlayersMap","queuedInstructions","allPreStyleElements","allPostStyleElements","disabledElementsSet","nodesThatAreDisabled","allTriggerElements","enterNodeMap","buildRootMap","enterNodeMapIds","nodes","root","className","allLeaveNodes","mergedLeaveNodes","leaveNodesWithoutAnimations","leaveNodeMapIds","leaveNodeMap","allPlayers","erroneousTransitions","previousValue","nodeIsOrphaned","stringMap","setVal","allPreviousPlayersMap","animationElementMap","_beforeAnimationBuild","_getPreviousPlayers","prevPlayer","replaceNodes","replacePostStylesAsPre","postStylesMap","allLeaveQueriedNodes","cloakAndComputeStyles","preStylesMap","post","pre","rootPlayers","subPlayers","NO_PARENT_ANIMATION_ELEMENT_DETECTED","disabled","overrideTotalTime","parentWithAnimation","parentsToAdd","detectedParent","innerPlayer","_buildAnimation","setRealPlayer","parentPlayers","parentPlayer","playersForElement","syncPlayerEvents","queriedPlayerResults","queriedInnerElements","j","queriedPlayers","activePlayers","removeNodesAfterAnimationDone","isQueriedElement","toStateValue","queriedElementPlayers","isRemovalAnimation","targetNameSpaceId","targetTriggerName","timelineInstruction","realPlayer","getRealPlayer","beforeDestroy","allQueriedPlayers","allConsumedElements","allSubElements","allNewPlayers","flattenGroupPlayers","pp","wrappedPlayer","deleteOrUnsetInMap","_player","_containsRealPlayer","_queuedCallbacks","callbacks","triggerCallback","_queueEvent","hasStarted","getPosition","phaseName","currentValues","cloakElement","oldValue","display","valuesMap","elementPropsMap","defaultStyle","cloakVals","failedElements","roots","rootMap","NULL_NODE","nodeSet","localRootMap","getRoot","remove","finalPlayers","_flattenGroupPlayersRecur","k1","k2","postEntry","preEntry","AnimationEngine","_transitionEngine","_timelineEngine","_triggerCache","doc","body","componentId","cacheKey","onInsert","onRemove","disableAnimations","disable","process","property","action","eventPhase","cb","packageNonAnimatableStyles","startStyles","endStyles","filterNonAnimatableStyles","SpecialCasedStyles","_element","_startStyles","_endStyles","initialStylesByElement","WeakMap","_state","_initialStyles","initialStyles","start","isNonAnimatableStyle","WebAnimationsPlayer","_specialStyles","_onDoneFns","_onStartFns","_onDestroyFns","_duration","_delay","_initialized","_finished","_started","_destroyed","_finalKeyframe","_originalOnDoneFns","_originalOnStartFns","domPlayer","currentSnapshot","_onFinish","_preparePlayerBeforeStart","_triggerWebAnimation","onFinish","addEventListener","removeEventListener","_resetDomPlayerState","_convertKeyframesToObject","kfs","frame","fromEntries","keyframesObject","cancel","methods","WebAnimationsDriver","cssProp","fill","playerOptions","previousStyles","previousWebAnimationPlayers","specialStyles","createEngine","Animation","_animationAst","buildTimelines","destinationStyles","dest","ANIMATION_PREFIX","DISABLE_ANIMATIONS_FLAG","BaseAnimationRenderer","delegate","_onDestroy","ɵtype","destroyNode","queueMicrotask","createElement","namespace","createComment","createText","appendChild","newChild","refChild","isMove","removeChild","oldChild","isHostElement","requireSynchronousElementRemoval","selectRootElement","selectorOrNode","preserveContent","nextSibling","setAttribute","el","removeAttribute","setStyle","flags","removeStyle","setProperty","setValue","AnimationRenderer","resolveElementFromTarget","parseTriggerCallbackName","event","countId","scheduleListenerCallback","document","window","dotIndex","substring","AnimationRendererFactory","_zone","_currentId","_microtaskId","_animationCallbacksBuffer","_rendererCache","_cdRecurDepth","createRenderer","EMPTY_NAMESPACE_ID","cache","renderer","onRendererDestroy","animationTriggers","begin","_scheduleCountTask","count","run","animationCallbacksBuffer","end","runOutsideAngular","componentReplaced","ɵAnimation","ɵAnimationEngine","ɵAnimationRenderer","ɵAnimationRendererFactory","ɵAnimationStyleNormalizer","ɵBaseAnimationRenderer","ɵENTER_CLASSNAME","ɵLEAVE_CLASSNAME","ɵNoopAnimationStyleNormalizer","ɵTransitionAnimationPlayer","ɵWebAnimationsDriver","ɵWebAnimationsPlayer","ɵWebAnimationsStyleNormalizer","ɵallowPreviousPlayerStylesMerge","ɵcamelCaseToDashCase","ɵcontainsElement","ɵcreateEngine","ɵgetParentElement","ɵinvokeQuery","ɵnormalizeKeyframes","ɵvalidateStyleProperty","ɵvalidateWebAnimatableStyleProperty"],"sources":["/home/dfirth2/fiber_route_calculator/frontend-angular/node_modules/@angular/animations/fesm2022/browser.mjs"],"sourcesContent":["/**\n * @license Angular v21.1.1\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\nimport { validateStyleProperty, containsElement, getParentElement, invokeQuery, dashCaseToCamelCase, invalidCssUnitValue, invalidExpression, invalidTransitionAlias, visitDslNode, invalidTrigger, invalidDefinition, extractStyleParams, invalidState, invalidStyleValue, SUBSTITUTION_EXPR_START, invalidParallelAnimation, validateStyleParams, invalidKeyframes, invalidOffset, keyframeOffsetsOutOfOrder, keyframesMissingOffsets, getOrSetDefaultValue, invalidStagger, resolveTiming, NG_TRIGGER_SELECTOR, NG_ANIMATING_SELECTOR, normalizeAnimationEntry, resolveTimingValue, interpolateParams, invalidQuery, registerFailed, normalizeKeyframes, LEAVE_CLASSNAME, ENTER_CLASSNAME, missingOrDestroyedAnimation, createAnimationFailed, optimizeGroupPlayer, missingPlayer, listenOnPlayer, makeAnimationEvent, triggerTransitionsFailed, eraseStyles, setStyles, transitionFailed, missingTrigger, missingEvent, unsupportedTriggerEvent, NG_TRIGGER_CLASSNAME, unregisteredTrigger, NG_ANIMATING_CLASSNAME, triggerBuildFailed, parseTimelineCommand, computeStyle, camelCaseToDashCase, validateWebAnimatableStyleProperty, allowPreviousPlayerStylesMerge, normalizeKeyframes$1, balancePreviousStylesIntoKeyframes, validationFailed, normalizeStyles, buildingFailed } from './_util-chunk.mjs';\nimport { NoopAnimationPlayer, AnimationMetadataType, style, AUTO_STYLE, ɵPRE_STYLE as _PRE_STYLE, AnimationGroupPlayer } from './_private_export-chunk.mjs';\n\nclass NoopAnimationDriver {\n  validateStyleProperty(prop) {\n    return validateStyleProperty(prop);\n  }\n  containsElement(elm1, elm2) {\n    return containsElement(elm1, elm2);\n  }\n  getParentElement(element) {\n    return getParentElement(element);\n  }\n  query(element, selector, multi) {\n    return invokeQuery(element, selector, multi);\n  }\n  computeStyle(element, prop, defaultValue) {\n    return defaultValue || '';\n  }\n  animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {\n    return new NoopAnimationPlayer(duration, delay);\n  }\n  static ɵfac = i0.ɵɵngDeclareFactory({\n    minVersion: \"12.0.0\",\n    version: \"21.1.1\",\n    ngImport: i0,\n    type: NoopAnimationDriver,\n    deps: [],\n    target: i0.ɵɵFactoryTarget.Injectable\n  });\n  static ɵprov = i0.ɵɵngDeclareInjectable({\n    minVersion: \"12.0.0\",\n    version: \"21.1.1\",\n    ngImport: i0,\n    type: NoopAnimationDriver\n  });\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"21.1.1\",\n  ngImport: i0,\n  type: NoopAnimationDriver,\n  decorators: [{\n    type: Injectable\n  }]\n});\nclass AnimationDriver {\n  static NOOP = new NoopAnimationDriver();\n}\n\nclass AnimationStyleNormalizer {}\nclass NoopAnimationStyleNormalizer {\n  normalizePropertyName(propertyName, errors) {\n    return propertyName;\n  }\n  normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {\n    return value;\n  }\n}\n\nconst DIMENSIONAL_PROP_SET = new Set(['width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight', 'left', 'top', 'bottom', 'right', 'fontSize', 'outlineWidth', 'outlineOffset', 'paddingTop', 'paddingLeft', 'paddingBottom', 'paddingRight', 'marginTop', 'marginLeft', 'marginBottom', 'marginRight', 'borderRadius', 'borderWidth', 'borderTopWidth', 'borderLeftWidth', 'borderRightWidth', 'borderBottomWidth', 'textIndent', 'perspective']);\nclass WebAnimationsStyleNormalizer extends AnimationStyleNormalizer {\n  normalizePropertyName(propertyName, errors) {\n    return dashCaseToCamelCase(propertyName);\n  }\n  normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {\n    let unit = '';\n    const strVal = value.toString().trim();\n    if (DIMENSIONAL_PROP_SET.has(normalizedProperty) && value !== 0 && value !== '0') {\n      if (typeof value === 'number') {\n        unit = 'px';\n      } else {\n        const valAndSuffixMatch = value.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n          errors.push(invalidCssUnitValue(userProvidedProperty, value));\n        }\n      }\n    }\n    return strVal + unit;\n  }\n}\n\nfunction createListOfWarnings(warnings) {\n  const LINE_START = '\\n - ';\n  return `${LINE_START}${warnings.filter(Boolean).map(warning => warning).join(LINE_START)}`;\n}\nfunction warnValidation(warnings) {\n  console.warn(`animation validation warnings:${createListOfWarnings(warnings)}`);\n}\nfunction warnTriggerBuild(name, warnings) {\n  console.warn(`The animation trigger \"${name}\" has built with the following warnings:${createListOfWarnings(warnings)}`);\n}\nfunction warnRegister(warnings) {\n  console.warn(`Animation built with the following warnings:${createListOfWarnings(warnings)}`);\n}\nfunction pushUnrecognizedPropertiesWarning(warnings, props) {\n  if (props.length) {\n    warnings.push(`The following provided properties are not recognized: ${props.join(', ')}`);\n  }\n}\n\nconst ANY_STATE = '*';\nfunction parseTransitionExpr(transitionValue, errors) {\n  const expressions = [];\n  if (typeof transitionValue == 'string') {\n    transitionValue.split(/\\s*,\\s*/).forEach(str => parseInnerTransitionStr(str, expressions, errors));\n  } else {\n    expressions.push(transitionValue);\n  }\n  return expressions;\n}\nfunction parseInnerTransitionStr(eventStr, expressions, errors) {\n  if (eventStr[0] == ':') {\n    const result = parseAnimationAlias(eventStr, errors);\n    if (typeof result == 'function') {\n      expressions.push(result);\n      return;\n    }\n    eventStr = result;\n  }\n  const match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n  if (match == null || match.length < 4) {\n    errors.push(invalidExpression(eventStr));\n    return expressions;\n  }\n  const fromState = match[1];\n  const separator = match[2];\n  const toState = match[3];\n  expressions.push(makeLambdaFromStates(fromState, toState));\n  const isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n  if (separator[0] == '<' && !isFullAnyStateExpr) {\n    expressions.push(makeLambdaFromStates(toState, fromState));\n  }\n  return;\n}\nfunction parseAnimationAlias(alias, errors) {\n  switch (alias) {\n    case ':enter':\n      return 'void => *';\n    case ':leave':\n      return '* => void';\n    case ':increment':\n      return (fromState, toState) => parseFloat(toState) > parseFloat(fromState);\n    case ':decrement':\n      return (fromState, toState) => parseFloat(toState) < parseFloat(fromState);\n    default:\n      errors.push(invalidTransitionAlias(alias));\n      return '* => *';\n  }\n}\nconst TRUE_BOOLEAN_VALUES = new Set(['true', '1']);\nconst FALSE_BOOLEAN_VALUES = new Set(['false', '0']);\nfunction makeLambdaFromStates(lhs, rhs) {\n  const LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);\n  const RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);\n  return (fromState, toState) => {\n    let lhsMatch = lhs == ANY_STATE || lhs == fromState;\n    let rhsMatch = rhs == ANY_STATE || rhs == toState;\n    if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === 'boolean') {\n      lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);\n    }\n    if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === 'boolean') {\n      rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);\n    }\n    return lhsMatch && rhsMatch;\n  };\n}\n\nconst SELF_TOKEN = ':self';\nconst SELF_TOKEN_REGEX = /* @__PURE__ */new RegExp(`s*${SELF_TOKEN}s*,?`, 'g');\nfunction buildAnimationAst(driver, metadata, errors, warnings) {\n  return new AnimationAstBuilderVisitor(driver).build(metadata, errors, warnings);\n}\nconst ROOT_SELECTOR = '';\nclass AnimationAstBuilderVisitor {\n  _driver;\n  constructor(_driver) {\n    this._driver = _driver;\n  }\n  build(metadata, errors, warnings) {\n    const context = new AnimationAstBuilderContext(errors);\n    this._resetContextStyleTimingState(context);\n    const ast = visitDslNode(this, normalizeAnimationEntry(metadata), context);\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (context.unsupportedCSSPropertiesFound.size) {\n        pushUnrecognizedPropertiesWarning(warnings, [...context.unsupportedCSSPropertiesFound.keys()]);\n      }\n    }\n    return ast;\n  }\n  _resetContextStyleTimingState(context) {\n    context.currentQuerySelector = ROOT_SELECTOR;\n    context.collectedStyles = new Map();\n    context.collectedStyles.set(ROOT_SELECTOR, new Map());\n    context.currentTime = 0;\n  }\n  visitTrigger(metadata, context) {\n    let queryCount = context.queryCount = 0;\n    let depCount = context.depCount = 0;\n    const states = [];\n    const transitions = [];\n    if (metadata.name.charAt(0) == '@') {\n      context.errors.push(invalidTrigger());\n    }\n    metadata.definitions.forEach(def => {\n      this._resetContextStyleTimingState(context);\n      if (def.type == AnimationMetadataType.State) {\n        const stateDef = def;\n        const name = stateDef.name;\n        name.toString().split(/\\s*,\\s*/).forEach(n => {\n          stateDef.name = n;\n          states.push(this.visitState(stateDef, context));\n        });\n        stateDef.name = name;\n      } else if (def.type == AnimationMetadataType.Transition) {\n        const transition = this.visitTransition(def, context);\n        queryCount += transition.queryCount;\n        depCount += transition.depCount;\n        transitions.push(transition);\n      } else {\n        context.errors.push(invalidDefinition());\n      }\n    });\n    return {\n      type: AnimationMetadataType.Trigger,\n      name: metadata.name,\n      states,\n      transitions,\n      queryCount,\n      depCount,\n      options: null\n    };\n  }\n  visitState(metadata, context) {\n    const styleAst = this.visitStyle(metadata.styles, context);\n    const astParams = metadata.options && metadata.options.params || null;\n    if (styleAst.containsDynamicStyles) {\n      const missingSubs = new Set();\n      const params = astParams || {};\n      styleAst.styles.forEach(style => {\n        if (style instanceof Map) {\n          style.forEach(value => {\n            extractStyleParams(value).forEach(sub => {\n              if (!params.hasOwnProperty(sub)) {\n                missingSubs.add(sub);\n              }\n            });\n          });\n        }\n      });\n      if (missingSubs.size) {\n        context.errors.push(invalidState(metadata.name, [...missingSubs.values()]));\n      }\n    }\n    return {\n      type: AnimationMetadataType.State,\n      name: metadata.name,\n      style: styleAst,\n      options: astParams ? {\n        params: astParams\n      } : null\n    };\n  }\n  visitTransition(metadata, context) {\n    context.queryCount = 0;\n    context.depCount = 0;\n    const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);\n    const matchers = parseTransitionExpr(metadata.expr, context.errors);\n    return {\n      type: AnimationMetadataType.Transition,\n      matchers,\n      animation,\n      queryCount: context.queryCount,\n      depCount: context.depCount,\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitSequence(metadata, context) {\n    return {\n      type: AnimationMetadataType.Sequence,\n      steps: metadata.steps.map(s => visitDslNode(this, s, context)),\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitGroup(metadata, context) {\n    const currentTime = context.currentTime;\n    let furthestTime = 0;\n    const steps = metadata.steps.map(step => {\n      context.currentTime = currentTime;\n      const innerAst = visitDslNode(this, step, context);\n      furthestTime = Math.max(furthestTime, context.currentTime);\n      return innerAst;\n    });\n    context.currentTime = furthestTime;\n    return {\n      type: AnimationMetadataType.Group,\n      steps,\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitAnimate(metadata, context) {\n    const timingAst = constructTimingAst(metadata.timings, context.errors);\n    context.currentAnimateTimings = timingAst;\n    let styleAst;\n    let styleMetadata = metadata.styles ? metadata.styles : style({});\n    if (styleMetadata.type == AnimationMetadataType.Keyframes) {\n      styleAst = this.visitKeyframes(styleMetadata, context);\n    } else {\n      let styleMetadata = metadata.styles;\n      let isEmpty = false;\n      if (!styleMetadata) {\n        isEmpty = true;\n        const newStyleData = {};\n        if (timingAst.easing) {\n          newStyleData['easing'] = timingAst.easing;\n        }\n        styleMetadata = style(newStyleData);\n      }\n      context.currentTime += timingAst.duration + timingAst.delay;\n      const _styleAst = this.visitStyle(styleMetadata, context);\n      _styleAst.isEmptyStep = isEmpty;\n      styleAst = _styleAst;\n    }\n    context.currentAnimateTimings = null;\n    return {\n      type: AnimationMetadataType.Animate,\n      timings: timingAst,\n      style: styleAst,\n      options: null\n    };\n  }\n  visitStyle(metadata, context) {\n    const ast = this._makeStyleAst(metadata, context);\n    this._validateStyleAst(ast, context);\n    return ast;\n  }\n  _makeStyleAst(metadata, context) {\n    const styles = [];\n    const metadataStyles = Array.isArray(metadata.styles) ? metadata.styles : [metadata.styles];\n    for (let styleTuple of metadataStyles) {\n      if (typeof styleTuple === 'string') {\n        if (styleTuple === AUTO_STYLE) {\n          styles.push(styleTuple);\n        } else {\n          context.errors.push(invalidStyleValue(styleTuple));\n        }\n      } else {\n        styles.push(new Map(Object.entries(styleTuple)));\n      }\n    }\n    let containsDynamicStyles = false;\n    let collectedEasing = null;\n    styles.forEach(styleData => {\n      if (styleData instanceof Map) {\n        if (styleData.has('easing')) {\n          collectedEasing = styleData.get('easing');\n          styleData.delete('easing');\n        }\n        if (!containsDynamicStyles) {\n          for (let value of styleData.values()) {\n            if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {\n              containsDynamicStyles = true;\n              break;\n            }\n          }\n        }\n      }\n    });\n    return {\n      type: AnimationMetadataType.Style,\n      styles,\n      easing: collectedEasing,\n      offset: metadata.offset,\n      containsDynamicStyles,\n      options: null\n    };\n  }\n  _validateStyleAst(ast, context) {\n    const timings = context.currentAnimateTimings;\n    let endTime = context.currentTime;\n    let startTime = context.currentTime;\n    if (timings && startTime > 0) {\n      startTime -= timings.duration + timings.delay;\n    }\n    ast.styles.forEach(tuple => {\n      if (typeof tuple === 'string') return;\n      tuple.forEach((value, prop) => {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          if (!this._driver.validateStyleProperty(prop)) {\n            tuple.delete(prop);\n            context.unsupportedCSSPropertiesFound.add(prop);\n            return;\n          }\n        }\n        const collectedStyles = context.collectedStyles.get(context.currentQuerySelector);\n        const collectedEntry = collectedStyles.get(prop);\n        let updateCollectedStyle = true;\n        if (collectedEntry) {\n          if (startTime != endTime && startTime >= collectedEntry.startTime && endTime <= collectedEntry.endTime) {\n            context.errors.push(invalidParallelAnimation(prop, collectedEntry.startTime, collectedEntry.endTime, startTime, endTime));\n            updateCollectedStyle = false;\n          }\n          startTime = collectedEntry.startTime;\n        }\n        if (updateCollectedStyle) {\n          collectedStyles.set(prop, {\n            startTime,\n            endTime\n          });\n        }\n        if (context.options) {\n          validateStyleParams(value, context.options, context.errors);\n        }\n      });\n    });\n  }\n  visitKeyframes(metadata, context) {\n    const ast = {\n      type: AnimationMetadataType.Keyframes,\n      styles: [],\n      options: null\n    };\n    if (!context.currentAnimateTimings) {\n      context.errors.push(invalidKeyframes());\n      return ast;\n    }\n    const MAX_KEYFRAME_OFFSET = 1;\n    let totalKeyframesWithOffsets = 0;\n    const offsets = [];\n    let offsetsOutOfOrder = false;\n    let keyframesOutOfRange = false;\n    let previousOffset = 0;\n    const keyframes = metadata.steps.map(styles => {\n      const style = this._makeStyleAst(styles, context);\n      let offsetVal = style.offset != null ? style.offset : consumeOffset(style.styles);\n      let offset = 0;\n      if (offsetVal != null) {\n        totalKeyframesWithOffsets++;\n        offset = style.offset = offsetVal;\n      }\n      keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;\n      offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;\n      previousOffset = offset;\n      offsets.push(offset);\n      return style;\n    });\n    if (keyframesOutOfRange) {\n      context.errors.push(invalidOffset());\n    }\n    if (offsetsOutOfOrder) {\n      context.errors.push(keyframeOffsetsOutOfOrder());\n    }\n    const length = metadata.steps.length;\n    let generatedOffset = 0;\n    if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {\n      context.errors.push(keyframesMissingOffsets());\n    } else if (totalKeyframesWithOffsets == 0) {\n      generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);\n    }\n    const limit = length - 1;\n    const currentTime = context.currentTime;\n    const currentAnimateTimings = context.currentAnimateTimings;\n    const animateDuration = currentAnimateTimings.duration;\n    keyframes.forEach((kf, i) => {\n      const offset = generatedOffset > 0 ? i == limit ? 1 : generatedOffset * i : offsets[i];\n      const durationUpToThisFrame = offset * animateDuration;\n      context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;\n      currentAnimateTimings.duration = durationUpToThisFrame;\n      this._validateStyleAst(kf, context);\n      kf.offset = offset;\n      ast.styles.push(kf);\n    });\n    return ast;\n  }\n  visitReference(metadata, context) {\n    return {\n      type: AnimationMetadataType.Reference,\n      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitAnimateChild(metadata, context) {\n    context.depCount++;\n    return {\n      type: AnimationMetadataType.AnimateChild,\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitAnimateRef(metadata, context) {\n    return {\n      type: AnimationMetadataType.AnimateRef,\n      animation: this.visitReference(metadata.animation, context),\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitQuery(metadata, context) {\n    const parentSelector = context.currentQuerySelector;\n    const options = metadata.options || {};\n    context.queryCount++;\n    context.currentQuery = metadata;\n    const [selector, includeSelf] = normalizeSelector(metadata.selector);\n    context.currentQuerySelector = parentSelector.length ? parentSelector + ' ' + selector : selector;\n    getOrSetDefaultValue(context.collectedStyles, context.currentQuerySelector, new Map());\n    const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);\n    context.currentQuery = null;\n    context.currentQuerySelector = parentSelector;\n    return {\n      type: AnimationMetadataType.Query,\n      selector,\n      limit: options.limit || 0,\n      optional: !!options.optional,\n      includeSelf,\n      animation,\n      originalSelector: metadata.selector,\n      options: normalizeAnimationOptions(metadata.options)\n    };\n  }\n  visitStagger(metadata, context) {\n    if (!context.currentQuery) {\n      context.errors.push(invalidStagger());\n    }\n    const timings = metadata.timings === 'full' ? {\n      duration: 0,\n      delay: 0,\n      easing: 'full'\n    } : resolveTiming(metadata.timings, context.errors, true);\n    return {\n      type: AnimationMetadataType.Stagger,\n      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),\n      timings,\n      options: null\n    };\n  }\n}\nfunction normalizeSelector(selector) {\n  const hasAmpersand = selector.split(/\\s*,\\s*/).find(token => token == SELF_TOKEN) ? true : false;\n  if (hasAmpersand) {\n    selector = selector.replace(SELF_TOKEN_REGEX, '');\n  }\n  selector = selector.replace(/@\\*/g, NG_TRIGGER_SELECTOR).replace(/@\\w+/g, match => NG_TRIGGER_SELECTOR + '-' + match.slice(1)).replace(/:animating/g, NG_ANIMATING_SELECTOR);\n  return [selector, hasAmpersand];\n}\nfunction normalizeParams(obj) {\n  return obj ? {\n    ...obj\n  } : null;\n}\nclass AnimationAstBuilderContext {\n  errors;\n  queryCount = 0;\n  depCount = 0;\n  currentTransition = null;\n  currentQuery = null;\n  currentQuerySelector = null;\n  currentAnimateTimings = null;\n  currentTime = 0;\n  collectedStyles = new Map();\n  options = null;\n  unsupportedCSSPropertiesFound = new Set();\n  constructor(errors) {\n    this.errors = errors;\n  }\n}\nfunction consumeOffset(styles) {\n  if (typeof styles == 'string') return null;\n  let offset = null;\n  if (Array.isArray(styles)) {\n    styles.forEach(styleTuple => {\n      if (styleTuple instanceof Map && styleTuple.has('offset')) {\n        const obj = styleTuple;\n        offset = parseFloat(obj.get('offset'));\n        obj.delete('offset');\n      }\n    });\n  } else if (styles instanceof Map && styles.has('offset')) {\n    const obj = styles;\n    offset = parseFloat(obj.get('offset'));\n    obj.delete('offset');\n  }\n  return offset;\n}\nfunction constructTimingAst(value, errors) {\n  if (value.hasOwnProperty('duration')) {\n    return value;\n  }\n  if (typeof value == 'number') {\n    const duration = resolveTiming(value, errors).duration;\n    return makeTimingAst(duration, 0, '');\n  }\n  const strValue = value;\n  const isDynamic = strValue.split(/\\s+/).some(v => v.charAt(0) == '{' && v.charAt(1) == '{');\n  if (isDynamic) {\n    const ast = makeTimingAst(0, 0, '');\n    ast.dynamic = true;\n    ast.strValue = strValue;\n    return ast;\n  }\n  const timings = resolveTiming(strValue, errors);\n  return makeTimingAst(timings.duration, timings.delay, timings.easing);\n}\nfunction normalizeAnimationOptions(options) {\n  if (options) {\n    options = {\n      ...options\n    };\n    if (options['params']) {\n      options['params'] = normalizeParams(options['params']);\n    }\n  } else {\n    options = {};\n  }\n  return options;\n}\nfunction makeTimingAst(duration, delay, easing) {\n  return {\n    duration,\n    delay,\n    easing\n  };\n}\n\nfunction createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing = null, subTimeline = false) {\n  return {\n    type: 1,\n    element,\n    keyframes,\n    preStyleProps,\n    postStyleProps,\n    duration,\n    delay,\n    totalTime: duration + delay,\n    easing,\n    subTimeline\n  };\n}\n\nclass ElementInstructionMap {\n  _map = new Map();\n  get(element) {\n    return this._map.get(element) || [];\n  }\n  append(element, instructions) {\n    let existingInstructions = this._map.get(element);\n    if (!existingInstructions) {\n      this._map.set(element, existingInstructions = []);\n    }\n    existingInstructions.push(...instructions);\n  }\n  has(element) {\n    return this._map.has(element);\n  }\n  clear() {\n    this._map.clear();\n  }\n}\n\nconst ONE_FRAME_IN_MILLISECONDS = 1;\nconst ENTER_TOKEN = ':enter';\nconst ENTER_TOKEN_REGEX = /* @__PURE__ */new RegExp(ENTER_TOKEN, 'g');\nconst LEAVE_TOKEN = ':leave';\nconst LEAVE_TOKEN_REGEX = /* @__PURE__ */new RegExp(LEAVE_TOKEN, 'g');\nfunction buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles = new Map(), finalStyles = new Map(), options, subInstructions, errors = []) {\n  return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);\n}\nclass AnimationTimelineBuilderVisitor {\n  buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors = []) {\n    subInstructions = subInstructions || new ElementInstructionMap();\n    const context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);\n    context.options = options;\n    const delay = options.delay ? resolveTimingValue(options.delay) : 0;\n    context.currentTimeline.delayNextStep(delay);\n    context.currentTimeline.setStyles([startingStyles], null, context.errors, options);\n    visitDslNode(this, ast, context);\n    const timelines = context.timelines.filter(timeline => timeline.containsAnimation());\n    if (timelines.length && finalStyles.size) {\n      let lastRootTimeline;\n      for (let i = timelines.length - 1; i >= 0; i--) {\n        const timeline = timelines[i];\n        if (timeline.element === rootElement) {\n          lastRootTimeline = timeline;\n          break;\n        }\n      }\n      if (lastRootTimeline && !lastRootTimeline.allowOnlyTimelineStyles()) {\n        lastRootTimeline.setStyles([finalStyles], null, context.errors, options);\n      }\n    }\n    return timelines.length ? timelines.map(timeline => timeline.buildKeyframes()) : [createTimelineInstruction(rootElement, [], [], [], 0, delay, '', false)];\n  }\n  visitTrigger(ast, context) {}\n  visitState(ast, context) {}\n  visitTransition(ast, context) {}\n  visitAnimateChild(ast, context) {\n    const elementInstructions = context.subInstructions.get(context.element);\n    if (elementInstructions) {\n      const innerContext = context.createSubContext(ast.options);\n      const startTime = context.currentTimeline.currentTime;\n      const endTime = this._visitSubInstructions(elementInstructions, innerContext, innerContext.options);\n      if (startTime != endTime) {\n        context.transformIntoNewTimeline(endTime);\n      }\n    }\n    context.previousNode = ast;\n  }\n  visitAnimateRef(ast, context) {\n    const innerContext = context.createSubContext(ast.options);\n    innerContext.transformIntoNewTimeline();\n    this._applyAnimationRefDelays([ast.options, ast.animation.options], context, innerContext);\n    this.visitReference(ast.animation, innerContext);\n    context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);\n    context.previousNode = ast;\n  }\n  _applyAnimationRefDelays(animationsRefsOptions, context, innerContext) {\n    for (const animationRefOptions of animationsRefsOptions) {\n      const animationDelay = animationRefOptions?.delay;\n      if (animationDelay) {\n        const animationDelayValue = typeof animationDelay === 'number' ? animationDelay : resolveTimingValue(interpolateParams(animationDelay, animationRefOptions?.params ?? {}, context.errors));\n        innerContext.delayNextStep(animationDelayValue);\n      }\n    }\n  }\n  _visitSubInstructions(instructions, context, options) {\n    const startTime = context.currentTimeline.currentTime;\n    let furthestTime = startTime;\n    const duration = options.duration != null ? resolveTimingValue(options.duration) : null;\n    const delay = options.delay != null ? resolveTimingValue(options.delay) : null;\n    if (duration !== 0) {\n      instructions.forEach(instruction => {\n        const instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);\n        furthestTime = Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);\n      });\n    }\n    return furthestTime;\n  }\n  visitReference(ast, context) {\n    context.updateOptions(ast.options, true);\n    visitDslNode(this, ast.animation, context);\n    context.previousNode = ast;\n  }\n  visitSequence(ast, context) {\n    const subContextCount = context.subContextCount;\n    let ctx = context;\n    const options = ast.options;\n    if (options && (options.params || options.delay)) {\n      ctx = context.createSubContext(options);\n      ctx.transformIntoNewTimeline();\n      if (options.delay != null) {\n        if (ctx.previousNode.type == AnimationMetadataType.Style) {\n          ctx.currentTimeline.snapshotCurrentStyles();\n          ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n        }\n        const delay = resolveTimingValue(options.delay);\n        ctx.delayNextStep(delay);\n      }\n    }\n    if (ast.steps.length) {\n      ast.steps.forEach(s => visitDslNode(this, s, ctx));\n      ctx.currentTimeline.applyStylesToKeyframe();\n      if (ctx.subContextCount > subContextCount) {\n        ctx.transformIntoNewTimeline();\n      }\n    }\n    context.previousNode = ast;\n  }\n  visitGroup(ast, context) {\n    const innerTimelines = [];\n    let furthestTime = context.currentTimeline.currentTime;\n    const delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;\n    ast.steps.forEach(s => {\n      const innerContext = context.createSubContext(ast.options);\n      if (delay) {\n        innerContext.delayNextStep(delay);\n      }\n      visitDslNode(this, s, innerContext);\n      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);\n      innerTimelines.push(innerContext.currentTimeline);\n    });\n    innerTimelines.forEach(timeline => context.currentTimeline.mergeTimelineCollectedStyles(timeline));\n    context.transformIntoNewTimeline(furthestTime);\n    context.previousNode = ast;\n  }\n  _visitTiming(ast, context) {\n    if (ast.dynamic) {\n      const strValue = ast.strValue;\n      const timingValue = context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;\n      return resolveTiming(timingValue, context.errors);\n    } else {\n      return {\n        duration: ast.duration,\n        delay: ast.delay,\n        easing: ast.easing\n      };\n    }\n  }\n  visitAnimate(ast, context) {\n    const timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);\n    const timeline = context.currentTimeline;\n    if (timings.delay) {\n      context.incrementTime(timings.delay);\n      timeline.snapshotCurrentStyles();\n    }\n    const style = ast.style;\n    if (style.type == AnimationMetadataType.Keyframes) {\n      this.visitKeyframes(style, context);\n    } else {\n      context.incrementTime(timings.duration);\n      this.visitStyle(style, context);\n      timeline.applyStylesToKeyframe();\n    }\n    context.currentAnimateTimings = null;\n    context.previousNode = ast;\n  }\n  visitStyle(ast, context) {\n    const timeline = context.currentTimeline;\n    const timings = context.currentAnimateTimings;\n    if (!timings && timeline.hasCurrentStyleProperties()) {\n      timeline.forwardFrame();\n    }\n    const easing = timings && timings.easing || ast.easing;\n    if (ast.isEmptyStep) {\n      timeline.applyEmptyStep(easing);\n    } else {\n      timeline.setStyles(ast.styles, easing, context.errors, context.options);\n    }\n    context.previousNode = ast;\n  }\n  visitKeyframes(ast, context) {\n    const currentAnimateTimings = context.currentAnimateTimings;\n    const startTime = context.currentTimeline.duration;\n    const duration = currentAnimateTimings.duration;\n    const innerContext = context.createSubContext();\n    const innerTimeline = innerContext.currentTimeline;\n    innerTimeline.easing = currentAnimateTimings.easing;\n    ast.styles.forEach(step => {\n      const offset = step.offset || 0;\n      innerTimeline.forwardTime(offset * duration);\n      innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);\n      innerTimeline.applyStylesToKeyframe();\n    });\n    context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);\n    context.transformIntoNewTimeline(startTime + duration);\n    context.previousNode = ast;\n  }\n  visitQuery(ast, context) {\n    const startTime = context.currentTimeline.currentTime;\n    const options = ast.options || {};\n    const delay = options.delay ? resolveTimingValue(options.delay) : 0;\n    if (delay && (context.previousNode.type === AnimationMetadataType.Style || startTime == 0 && context.currentTimeline.hasCurrentStyleProperties())) {\n      context.currentTimeline.snapshotCurrentStyles();\n      context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n    }\n    let furthestTime = startTime;\n    const elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);\n    context.currentQueryTotal = elms.length;\n    let sameElementTimeline = null;\n    elms.forEach((element, i) => {\n      context.currentQueryIndex = i;\n      const innerContext = context.createSubContext(ast.options, element);\n      if (delay) {\n        innerContext.delayNextStep(delay);\n      }\n      if (element === context.element) {\n        sameElementTimeline = innerContext.currentTimeline;\n      }\n      visitDslNode(this, ast.animation, innerContext);\n      innerContext.currentTimeline.applyStylesToKeyframe();\n      const endTime = innerContext.currentTimeline.currentTime;\n      furthestTime = Math.max(furthestTime, endTime);\n    });\n    context.currentQueryIndex = 0;\n    context.currentQueryTotal = 0;\n    context.transformIntoNewTimeline(furthestTime);\n    if (sameElementTimeline) {\n      context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);\n      context.currentTimeline.snapshotCurrentStyles();\n    }\n    context.previousNode = ast;\n  }\n  visitStagger(ast, context) {\n    const parentContext = context.parentContext;\n    const tl = context.currentTimeline;\n    const timings = ast.timings;\n    const duration = Math.abs(timings.duration);\n    const maxTime = duration * (context.currentQueryTotal - 1);\n    let delay = duration * context.currentQueryIndex;\n    let staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;\n    switch (staggerTransformer) {\n      case 'reverse':\n        delay = maxTime - delay;\n        break;\n      case 'full':\n        delay = parentContext.currentStaggerTime;\n        break;\n    }\n    const timeline = context.currentTimeline;\n    if (delay) {\n      timeline.delayNextStep(delay);\n    }\n    const startingTime = timeline.currentTime;\n    visitDslNode(this, ast.animation, context);\n    context.previousNode = ast;\n    parentContext.currentStaggerTime = tl.currentTime - startingTime + (tl.startTime - parentContext.currentTimeline.startTime);\n  }\n}\nconst DEFAULT_NOOP_PREVIOUS_NODE = {};\nclass AnimationTimelineContext {\n  _driver;\n  element;\n  subInstructions;\n  _enterClassName;\n  _leaveClassName;\n  errors;\n  timelines;\n  parentContext = null;\n  currentTimeline;\n  currentAnimateTimings = null;\n  previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n  subContextCount = 0;\n  options = {};\n  currentQueryIndex = 0;\n  currentQueryTotal = 0;\n  currentStaggerTime = 0;\n  constructor(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {\n    this._driver = _driver;\n    this.element = element;\n    this.subInstructions = subInstructions;\n    this._enterClassName = _enterClassName;\n    this._leaveClassName = _leaveClassName;\n    this.errors = errors;\n    this.timelines = timelines;\n    this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);\n    timelines.push(this.currentTimeline);\n  }\n  get params() {\n    return this.options.params;\n  }\n  updateOptions(options, skipIfExists) {\n    if (!options) return;\n    const newOptions = options;\n    let optionsToUpdate = this.options;\n    if (newOptions.duration != null) {\n      optionsToUpdate.duration = resolveTimingValue(newOptions.duration);\n    }\n    if (newOptions.delay != null) {\n      optionsToUpdate.delay = resolveTimingValue(newOptions.delay);\n    }\n    const newParams = newOptions.params;\n    if (newParams) {\n      let paramsToUpdate = optionsToUpdate.params;\n      if (!paramsToUpdate) {\n        paramsToUpdate = this.options.params = {};\n      }\n      Object.keys(newParams).forEach(name => {\n        if (!skipIfExists || !paramsToUpdate.hasOwnProperty(name)) {\n          paramsToUpdate[name] = interpolateParams(newParams[name], paramsToUpdate, this.errors);\n        }\n      });\n    }\n  }\n  _copyOptions() {\n    const options = {};\n    if (this.options) {\n      const oldParams = this.options.params;\n      if (oldParams) {\n        const params = options['params'] = {};\n        Object.keys(oldParams).forEach(name => {\n          params[name] = oldParams[name];\n        });\n      }\n    }\n    return options;\n  }\n  createSubContext(options = null, element, newTime) {\n    const target = element || this.element;\n    const context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));\n    context.previousNode = this.previousNode;\n    context.currentAnimateTimings = this.currentAnimateTimings;\n    context.options = this._copyOptions();\n    context.updateOptions(options);\n    context.currentQueryIndex = this.currentQueryIndex;\n    context.currentQueryTotal = this.currentQueryTotal;\n    context.parentContext = this;\n    this.subContextCount++;\n    return context;\n  }\n  transformIntoNewTimeline(newTime) {\n    this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n    this.currentTimeline = this.currentTimeline.fork(this.element, newTime);\n    this.timelines.push(this.currentTimeline);\n    return this.currentTimeline;\n  }\n  appendInstructionToTimeline(instruction, duration, delay) {\n    const updatedTimings = {\n      duration: duration != null ? duration : instruction.duration,\n      delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,\n      easing: ''\n    };\n    const builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);\n    this.timelines.push(builder);\n    return updatedTimings;\n  }\n  incrementTime(time) {\n    this.currentTimeline.forwardTime(this.currentTimeline.duration + time);\n  }\n  delayNextStep(delay) {\n    if (delay > 0) {\n      this.currentTimeline.delayNextStep(delay);\n    }\n  }\n  invokeQuery(selector, originalSelector, limit, includeSelf, optional, errors) {\n    let results = [];\n    if (includeSelf) {\n      results.push(this.element);\n    }\n    if (selector.length > 0) {\n      selector = selector.replace(ENTER_TOKEN_REGEX, '.' + this._enterClassName);\n      selector = selector.replace(LEAVE_TOKEN_REGEX, '.' + this._leaveClassName);\n      const multi = limit != 1;\n      let elements = this._driver.query(this.element, selector, multi);\n      if (limit !== 0) {\n        elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) : elements.slice(0, limit);\n      }\n      results.push(...elements);\n    }\n    if (!optional && results.length == 0) {\n      errors.push(invalidQuery(originalSelector));\n    }\n    return results;\n  }\n}\nclass TimelineBuilder {\n  _driver;\n  element;\n  startTime;\n  _elementTimelineStylesLookup;\n  duration = 0;\n  easing = null;\n  _previousKeyframe = new Map();\n  _currentKeyframe = new Map();\n  _keyframes = new Map();\n  _styleSummary = new Map();\n  _localTimelineStyles = new Map();\n  _globalTimelineStyles;\n  _pendingStyles = new Map();\n  _backFill = new Map();\n  _currentEmptyStepKeyframe = null;\n  constructor(_driver, element, startTime, _elementTimelineStylesLookup) {\n    this._driver = _driver;\n    this.element = element;\n    this.startTime = startTime;\n    this._elementTimelineStylesLookup = _elementTimelineStylesLookup;\n    if (!this._elementTimelineStylesLookup) {\n      this._elementTimelineStylesLookup = new Map();\n    }\n    this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element);\n    if (!this._globalTimelineStyles) {\n      this._globalTimelineStyles = this._localTimelineStyles;\n      this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);\n    }\n    this._loadKeyframe();\n  }\n  containsAnimation() {\n    switch (this._keyframes.size) {\n      case 0:\n        return false;\n      case 1:\n        return this.hasCurrentStyleProperties();\n      default:\n        return true;\n    }\n  }\n  hasCurrentStyleProperties() {\n    return this._currentKeyframe.size > 0;\n  }\n  get currentTime() {\n    return this.startTime + this.duration;\n  }\n  delayNextStep(delay) {\n    const hasPreStyleStep = this._keyframes.size === 1 && this._pendingStyles.size;\n    if (this.duration || hasPreStyleStep) {\n      this.forwardTime(this.currentTime + delay);\n      if (hasPreStyleStep) {\n        this.snapshotCurrentStyles();\n      }\n    } else {\n      this.startTime += delay;\n    }\n  }\n  fork(element, currentTime) {\n    this.applyStylesToKeyframe();\n    return new TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);\n  }\n  _loadKeyframe() {\n    if (this._currentKeyframe) {\n      this._previousKeyframe = this._currentKeyframe;\n    }\n    this._currentKeyframe = this._keyframes.get(this.duration);\n    if (!this._currentKeyframe) {\n      this._currentKeyframe = new Map();\n      this._keyframes.set(this.duration, this._currentKeyframe);\n    }\n  }\n  forwardFrame() {\n    this.duration += ONE_FRAME_IN_MILLISECONDS;\n    this._loadKeyframe();\n  }\n  forwardTime(time) {\n    this.applyStylesToKeyframe();\n    this.duration = time;\n    this._loadKeyframe();\n  }\n  _updateStyle(prop, value) {\n    this._localTimelineStyles.set(prop, value);\n    this._globalTimelineStyles.set(prop, value);\n    this._styleSummary.set(prop, {\n      time: this.currentTime,\n      value\n    });\n  }\n  allowOnlyTimelineStyles() {\n    return this._currentEmptyStepKeyframe !== this._currentKeyframe;\n  }\n  applyEmptyStep(easing) {\n    if (easing) {\n      this._previousKeyframe.set('easing', easing);\n    }\n    for (let [prop, value] of this._globalTimelineStyles) {\n      this._backFill.set(prop, value || AUTO_STYLE);\n      this._currentKeyframe.set(prop, AUTO_STYLE);\n    }\n    this._currentEmptyStepKeyframe = this._currentKeyframe;\n  }\n  setStyles(input, easing, errors, options) {\n    if (easing) {\n      this._previousKeyframe.set('easing', easing);\n    }\n    const params = options && options.params || {};\n    const styles = flattenStyles(input, this._globalTimelineStyles);\n    for (let [prop, value] of styles) {\n      const val = interpolateParams(value, params, errors);\n      this._pendingStyles.set(prop, val);\n      if (!this._localTimelineStyles.has(prop)) {\n        this._backFill.set(prop, this._globalTimelineStyles.get(prop) ?? AUTO_STYLE);\n      }\n      this._updateStyle(prop, val);\n    }\n  }\n  applyStylesToKeyframe() {\n    if (this._pendingStyles.size == 0) return;\n    this._pendingStyles.forEach((val, prop) => {\n      this._currentKeyframe.set(prop, val);\n    });\n    this._pendingStyles.clear();\n    this._localTimelineStyles.forEach((val, prop) => {\n      if (!this._currentKeyframe.has(prop)) {\n        this._currentKeyframe.set(prop, val);\n      }\n    });\n  }\n  snapshotCurrentStyles() {\n    for (let [prop, val] of this._localTimelineStyles) {\n      this._pendingStyles.set(prop, val);\n      this._updateStyle(prop, val);\n    }\n  }\n  getFinalKeyframe() {\n    return this._keyframes.get(this.duration);\n  }\n  get properties() {\n    const properties = [];\n    for (let prop in this._currentKeyframe) {\n      properties.push(prop);\n    }\n    return properties;\n  }\n  mergeTimelineCollectedStyles(timeline) {\n    timeline._styleSummary.forEach((details1, prop) => {\n      const details0 = this._styleSummary.get(prop);\n      if (!details0 || details1.time > details0.time) {\n        this._updateStyle(prop, details1.value);\n      }\n    });\n  }\n  buildKeyframes() {\n    this.applyStylesToKeyframe();\n    const preStyleProps = new Set();\n    const postStyleProps = new Set();\n    const isEmpty = this._keyframes.size === 1 && this.duration === 0;\n    let finalKeyframes = [];\n    this._keyframes.forEach((keyframe, time) => {\n      const finalKeyframe = new Map([...this._backFill, ...keyframe]);\n      finalKeyframe.forEach((value, prop) => {\n        if (value === _PRE_STYLE) {\n          preStyleProps.add(prop);\n        } else if (value === AUTO_STYLE) {\n          postStyleProps.add(prop);\n        }\n      });\n      if (!isEmpty) {\n        finalKeyframe.set('offset', time / this.duration);\n      }\n      finalKeyframes.push(finalKeyframe);\n    });\n    const preProps = [...preStyleProps.values()];\n    const postProps = [...postStyleProps.values()];\n    if (isEmpty) {\n      const kf0 = finalKeyframes[0];\n      const kf1 = new Map(kf0);\n      kf0.set('offset', 0);\n      kf1.set('offset', 1);\n      finalKeyframes = [kf0, kf1];\n    }\n    return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);\n  }\n}\nclass SubTimelineBuilder extends TimelineBuilder {\n  keyframes;\n  preStyleProps;\n  postStyleProps;\n  _stretchStartingKeyframe;\n  timings;\n  constructor(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe = false) {\n    super(driver, element, timings.delay);\n    this.keyframes = keyframes;\n    this.preStyleProps = preStyleProps;\n    this.postStyleProps = postStyleProps;\n    this._stretchStartingKeyframe = _stretchStartingKeyframe;\n    this.timings = {\n      duration: timings.duration,\n      delay: timings.delay,\n      easing: timings.easing\n    };\n  }\n  containsAnimation() {\n    return this.keyframes.length > 1;\n  }\n  buildKeyframes() {\n    let keyframes = this.keyframes;\n    let {\n      delay,\n      duration,\n      easing\n    } = this.timings;\n    if (this._stretchStartingKeyframe && delay) {\n      const newKeyframes = [];\n      const totalTime = duration + delay;\n      const startingGap = delay / totalTime;\n      const newFirstKeyframe = new Map(keyframes[0]);\n      newFirstKeyframe.set('offset', 0);\n      newKeyframes.push(newFirstKeyframe);\n      const oldFirstKeyframe = new Map(keyframes[0]);\n      oldFirstKeyframe.set('offset', roundOffset(startingGap));\n      newKeyframes.push(oldFirstKeyframe);\n      const limit = keyframes.length - 1;\n      for (let i = 1; i <= limit; i++) {\n        let kf = new Map(keyframes[i]);\n        const oldOffset = kf.get('offset');\n        const timeAtKeyframe = delay + oldOffset * duration;\n        kf.set('offset', roundOffset(timeAtKeyframe / totalTime));\n        newKeyframes.push(kf);\n      }\n      duration = totalTime;\n      delay = 0;\n      easing = '';\n      keyframes = newKeyframes;\n    }\n    return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);\n  }\n}\nfunction roundOffset(offset, decimalPoints = 3) {\n  const mult = Math.pow(10, decimalPoints - 1);\n  return Math.round(offset * mult) / mult;\n}\nfunction flattenStyles(input, allStyles) {\n  const styles = new Map();\n  let allProperties;\n  input.forEach(token => {\n    if (token === '*') {\n      allProperties ??= allStyles.keys();\n      for (let prop of allProperties) {\n        styles.set(prop, AUTO_STYLE);\n      }\n    } else {\n      for (let [prop, val] of token) {\n        styles.set(prop, val);\n      }\n    }\n  });\n  return styles;\n}\n\nfunction createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {\n  return {\n    type: 0,\n    element,\n    triggerName,\n    isRemovalTransition,\n    fromState,\n    fromStyles,\n    toState,\n    toStyles,\n    timelines,\n    queriedElements,\n    preStyleProps,\n    postStyleProps,\n    totalTime,\n    errors\n  };\n}\n\nconst EMPTY_OBJECT = {};\nclass AnimationTransitionFactory {\n  _triggerName;\n  ast;\n  _stateStyles;\n  constructor(_triggerName, ast, _stateStyles) {\n    this._triggerName = _triggerName;\n    this.ast = ast;\n    this._stateStyles = _stateStyles;\n  }\n  match(currentState, nextState, element, params) {\n    return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState, element, params);\n  }\n  buildStyles(stateName, params, errors) {\n    let styler = this._stateStyles.get('*');\n    if (stateName !== undefined) {\n      styler = this._stateStyles.get(stateName?.toString()) || styler;\n    }\n    return styler ? styler.buildStyles(params, errors) : new Map();\n  }\n  build(driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {\n    const errors = [];\n    const transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;\n    const currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;\n    const currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);\n    const nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;\n    const nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);\n    const queriedElements = new Set();\n    const preStyleMap = new Map();\n    const postStyleMap = new Map();\n    const isRemoval = nextState === 'void';\n    const animationOptions = {\n      params: applyParamDefaults(nextAnimationParams, transitionAnimationParams),\n      delay: this.ast.options?.delay\n    };\n    const timelines = skipAstBuild ? [] : buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);\n    let totalTime = 0;\n    timelines.forEach(tl => {\n      totalTime = Math.max(tl.duration + tl.delay, totalTime);\n    });\n    if (errors.length) {\n      return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);\n    }\n    timelines.forEach(tl => {\n      const elm = tl.element;\n      const preProps = getOrSetDefaultValue(preStyleMap, elm, new Set());\n      tl.preStyleProps.forEach(prop => preProps.add(prop));\n      const postProps = getOrSetDefaultValue(postStyleMap, elm, new Set());\n      tl.postStyleProps.forEach(prop => postProps.add(prop));\n      if (elm !== element) {\n        queriedElements.add(elm);\n      }\n    });\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      checkNonAnimatableInTimelines(timelines, this._triggerName, driver);\n    }\n    return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, [...queriedElements.values()], preStyleMap, postStyleMap, totalTime);\n  }\n}\nfunction checkNonAnimatableInTimelines(timelines, triggerName, driver) {\n  if (!driver.validateAnimatableStyleProperty) {\n    return;\n  }\n  const allowedNonAnimatableProps = new Set(['easing']);\n  const invalidNonAnimatableProps = new Set();\n  timelines.forEach(({\n    keyframes\n  }) => {\n    const nonAnimatablePropsInitialValues = new Map();\n    keyframes.forEach(keyframe => {\n      const entriesToCheck = Array.from(keyframe.entries()).filter(([prop]) => !allowedNonAnimatableProps.has(prop));\n      for (const [prop, value] of entriesToCheck) {\n        if (!driver.validateAnimatableStyleProperty(prop)) {\n          if (nonAnimatablePropsInitialValues.has(prop) && !invalidNonAnimatableProps.has(prop)) {\n            const propInitialValue = nonAnimatablePropsInitialValues.get(prop);\n            if (propInitialValue !== value) {\n              invalidNonAnimatableProps.add(prop);\n            }\n          } else {\n            nonAnimatablePropsInitialValues.set(prop, value);\n          }\n        }\n      }\n    });\n  });\n  if (invalidNonAnimatableProps.size > 0) {\n    console.warn(`Warning: The animation trigger \"${triggerName}\" is attempting to animate the following` + ' not animatable properties: ' + Array.from(invalidNonAnimatableProps).join(', ') + '\\n' + '(to check the list of all animatable properties visit https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties)');\n  }\n}\nfunction oneOrMoreTransitionsMatch(matchFns, currentState, nextState, element, params) {\n  return matchFns.some(fn => fn(currentState, nextState, element, params));\n}\nfunction applyParamDefaults(userParams, defaults) {\n  const result = {\n    ...defaults\n  };\n  Object.entries(userParams).forEach(([key, value]) => {\n    if (value != null) {\n      result[key] = value;\n    }\n  });\n  return result;\n}\nclass AnimationStateStyles {\n  styles;\n  defaultParams;\n  normalizer;\n  constructor(styles, defaultParams, normalizer) {\n    this.styles = styles;\n    this.defaultParams = defaultParams;\n    this.normalizer = normalizer;\n  }\n  buildStyles(params, errors) {\n    const finalStyles = new Map();\n    const combinedParams = applyParamDefaults(params, this.defaultParams);\n    this.styles.styles.forEach(value => {\n      if (typeof value !== 'string') {\n        value.forEach((val, prop) => {\n          if (val) {\n            val = interpolateParams(val, combinedParams, errors);\n          }\n          const normalizedProp = this.normalizer.normalizePropertyName(prop, errors);\n          val = this.normalizer.normalizeStyleValue(prop, normalizedProp, val, errors);\n          finalStyles.set(prop, val);\n        });\n      }\n    });\n    return finalStyles;\n  }\n}\n\nfunction buildTrigger(name, ast, normalizer) {\n  return new AnimationTrigger(name, ast, normalizer);\n}\nclass AnimationTrigger {\n  name;\n  ast;\n  _normalizer;\n  transitionFactories = [];\n  fallbackTransition;\n  states = new Map();\n  constructor(name, ast, _normalizer) {\n    this.name = name;\n    this.ast = ast;\n    this._normalizer = _normalizer;\n    ast.states.forEach(ast => {\n      const defaultParams = ast.options && ast.options.params || {};\n      this.states.set(ast.name, new AnimationStateStyles(ast.style, defaultParams, _normalizer));\n    });\n    balanceProperties(this.states, 'true', '1');\n    balanceProperties(this.states, 'false', '0');\n    ast.transitions.forEach(ast => {\n      this.transitionFactories.push(new AnimationTransitionFactory(name, ast, this.states));\n    });\n    this.fallbackTransition = createFallbackTransition(name, this.states);\n  }\n  get containsQueries() {\n    return this.ast.queryCount > 0;\n  }\n  matchTransition(currentState, nextState, element, params) {\n    const entry = this.transitionFactories.find(f => f.match(currentState, nextState, element, params));\n    return entry || null;\n  }\n  matchStyles(currentState, params, errors) {\n    return this.fallbackTransition.buildStyles(currentState, params, errors);\n  }\n}\nfunction createFallbackTransition(triggerName, states, normalizer) {\n  const matchers = [(fromState, toState) => true];\n  const animation = {\n    type: AnimationMetadataType.Sequence,\n    steps: [],\n    options: null\n  };\n  const transition = {\n    type: AnimationMetadataType.Transition,\n    animation,\n    matchers,\n    options: null,\n    queryCount: 0,\n    depCount: 0\n  };\n  return new AnimationTransitionFactory(triggerName, transition, states);\n}\nfunction balanceProperties(stateMap, key1, key2) {\n  if (stateMap.has(key1)) {\n    if (!stateMap.has(key2)) {\n      stateMap.set(key2, stateMap.get(key1));\n    }\n  } else if (stateMap.has(key2)) {\n    stateMap.set(key1, stateMap.get(key2));\n  }\n}\n\nconst EMPTY_INSTRUCTION_MAP = /* @__PURE__ */new ElementInstructionMap();\nclass TimelineAnimationEngine {\n  bodyNode;\n  _driver;\n  _normalizer;\n  _animations = new Map();\n  _playersById = new Map();\n  players = [];\n  constructor(bodyNode, _driver, _normalizer) {\n    this.bodyNode = bodyNode;\n    this._driver = _driver;\n    this._normalizer = _normalizer;\n  }\n  register(id, metadata) {\n    const errors = [];\n    const warnings = [];\n    const ast = buildAnimationAst(this._driver, metadata, errors, warnings);\n    if (errors.length) {\n      throw registerFailed(errors);\n    } else {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (warnings.length) {\n          warnRegister(warnings);\n        }\n      }\n      this._animations.set(id, ast);\n    }\n  }\n  _buildPlayer(i, preStyles, postStyles) {\n    const element = i.element;\n    const keyframes = normalizeKeyframes(this._normalizer, i.keyframes, preStyles, postStyles);\n    return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, [], true);\n  }\n  create(id, element, options = {}) {\n    const errors = [];\n    const ast = this._animations.get(id);\n    let instructions;\n    const autoStylesMap = new Map();\n    if (ast) {\n      instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, new Map(), new Map(), options, EMPTY_INSTRUCTION_MAP, errors);\n      instructions.forEach(inst => {\n        const styles = getOrSetDefaultValue(autoStylesMap, inst.element, new Map());\n        inst.postStyleProps.forEach(prop => styles.set(prop, null));\n      });\n    } else {\n      errors.push(missingOrDestroyedAnimation());\n      instructions = [];\n    }\n    if (errors.length) {\n      throw createAnimationFailed(errors);\n    }\n    autoStylesMap.forEach((styles, element) => {\n      styles.forEach((_, prop) => {\n        styles.set(prop, this._driver.computeStyle(element, prop, AUTO_STYLE));\n      });\n    });\n    const players = instructions.map(i => {\n      const styles = autoStylesMap.get(i.element);\n      return this._buildPlayer(i, new Map(), styles);\n    });\n    const player = optimizeGroupPlayer(players);\n    this._playersById.set(id, player);\n    player.onDestroy(() => this.destroy(id));\n    this.players.push(player);\n    return player;\n  }\n  destroy(id) {\n    const player = this._getPlayer(id);\n    player.destroy();\n    this._playersById.delete(id);\n    const index = this.players.indexOf(player);\n    if (index >= 0) {\n      this.players.splice(index, 1);\n    }\n  }\n  _getPlayer(id) {\n    const player = this._playersById.get(id);\n    if (!player) {\n      throw missingPlayer(id);\n    }\n    return player;\n  }\n  listen(id, element, eventName, callback) {\n    const baseEvent = makeAnimationEvent(element, '', '', '');\n    listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);\n    return () => {};\n  }\n  command(id, element, command, args) {\n    if (command == 'register') {\n      this.register(id, args[0]);\n      return;\n    }\n    if (command == 'create') {\n      const options = args[0] || {};\n      this.create(id, element, options);\n      return;\n    }\n    const player = this._getPlayer(id);\n    switch (command) {\n      case 'play':\n        player.play();\n        break;\n      case 'pause':\n        player.pause();\n        break;\n      case 'reset':\n        player.reset();\n        break;\n      case 'restart':\n        player.restart();\n        break;\n      case 'finish':\n        player.finish();\n        break;\n      case 'init':\n        player.init();\n        break;\n      case 'setPosition':\n        player.setPosition(parseFloat(args[0]));\n        break;\n      case 'destroy':\n        this.destroy(id);\n        break;\n    }\n  }\n}\n\nconst QUEUED_CLASSNAME = 'ng-animate-queued';\nconst QUEUED_SELECTOR = '.ng-animate-queued';\nconst DISABLED_CLASSNAME = 'ng-animate-disabled';\nconst DISABLED_SELECTOR = '.ng-animate-disabled';\nconst STAR_CLASSNAME = 'ng-star-inserted';\nconst STAR_SELECTOR = '.ng-star-inserted';\nconst EMPTY_PLAYER_ARRAY = [];\nconst NULL_REMOVAL_STATE = {\n  namespaceId: '',\n  setForRemoval: false,\n  setForMove: false,\n  hasAnimation: false,\n  removedBeforeQueried: false\n};\nconst NULL_REMOVED_QUERIED_STATE = {\n  namespaceId: '',\n  setForMove: false,\n  setForRemoval: false,\n  hasAnimation: false,\n  removedBeforeQueried: true\n};\nconst REMOVAL_FLAG = '__ng_removed';\nclass StateValue {\n  namespaceId;\n  value;\n  options;\n  get params() {\n    return this.options.params;\n  }\n  constructor(input, namespaceId = '') {\n    this.namespaceId = namespaceId;\n    const isObj = input && input.hasOwnProperty('value');\n    const value = isObj ? input['value'] : input;\n    this.value = normalizeTriggerValue(value);\n    if (isObj) {\n      const {\n        value,\n        ...options\n      } = input;\n      this.options = options;\n    } else {\n      this.options = {};\n    }\n    if (!this.options.params) {\n      this.options.params = {};\n    }\n  }\n  absorbOptions(options) {\n    const newParams = options.params;\n    if (newParams) {\n      const oldParams = this.options.params;\n      Object.keys(newParams).forEach(prop => {\n        if (oldParams[prop] == null) {\n          oldParams[prop] = newParams[prop];\n        }\n      });\n    }\n  }\n}\nconst VOID_VALUE = 'void';\nconst DEFAULT_STATE_VALUE = /* @__PURE__ */new StateValue(VOID_VALUE);\nclass AnimationTransitionNamespace {\n  id;\n  hostElement;\n  _engine;\n  players = [];\n  _triggers = new Map();\n  _queue = [];\n  _elementListeners = new Map();\n  _hostClassName;\n  constructor(id, hostElement, _engine) {\n    this.id = id;\n    this.hostElement = hostElement;\n    this._engine = _engine;\n    this._hostClassName = 'ng-tns-' + id;\n    addClass(hostElement, this._hostClassName);\n  }\n  listen(element, name, phase, callback) {\n    if (!this._triggers.has(name)) {\n      throw missingTrigger(phase, name);\n    }\n    if (phase == null || phase.length == 0) {\n      throw missingEvent(name);\n    }\n    if (!isTriggerEventValid(phase)) {\n      throw unsupportedTriggerEvent(phase, name);\n    }\n    const listeners = getOrSetDefaultValue(this._elementListeners, element, []);\n    const data = {\n      name,\n      phase,\n      callback\n    };\n    listeners.push(data);\n    const triggersWithStates = getOrSetDefaultValue(this._engine.statesByElement, element, new Map());\n    if (!triggersWithStates.has(name)) {\n      addClass(element, NG_TRIGGER_CLASSNAME);\n      addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);\n      triggersWithStates.set(name, DEFAULT_STATE_VALUE);\n    }\n    return () => {\n      this._engine.afterFlush(() => {\n        const index = listeners.indexOf(data);\n        if (index >= 0) {\n          listeners.splice(index, 1);\n        }\n        if (!this._triggers.has(name)) {\n          triggersWithStates.delete(name);\n        }\n      });\n    };\n  }\n  register(name, ast) {\n    if (this._triggers.has(name)) {\n      return false;\n    } else {\n      this._triggers.set(name, ast);\n      return true;\n    }\n  }\n  _getTrigger(name) {\n    const trigger = this._triggers.get(name);\n    if (!trigger) {\n      throw unregisteredTrigger(name);\n    }\n    return trigger;\n  }\n  trigger(element, triggerName, value, defaultToFallback = true) {\n    const trigger = this._getTrigger(triggerName);\n    const player = new TransitionAnimationPlayer(this.id, triggerName, element);\n    let triggersWithStates = this._engine.statesByElement.get(element);\n    if (!triggersWithStates) {\n      addClass(element, NG_TRIGGER_CLASSNAME);\n      addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);\n      this._engine.statesByElement.set(element, triggersWithStates = new Map());\n    }\n    let fromState = triggersWithStates.get(triggerName);\n    const toState = new StateValue(value, this.id);\n    const isObj = value && value.hasOwnProperty('value');\n    if (!isObj && fromState) {\n      toState.absorbOptions(fromState.options);\n    }\n    triggersWithStates.set(triggerName, toState);\n    if (!fromState) {\n      fromState = DEFAULT_STATE_VALUE;\n    }\n    const isRemoval = toState.value === VOID_VALUE;\n    if (!isRemoval && fromState.value === toState.value) {\n      if (!objEquals(fromState.params, toState.params)) {\n        const errors = [];\n        const fromStyles = trigger.matchStyles(fromState.value, fromState.params, errors);\n        const toStyles = trigger.matchStyles(toState.value, toState.params, errors);\n        if (errors.length) {\n          this._engine.reportError(errors);\n        } else {\n          this._engine.afterFlush(() => {\n            eraseStyles(element, fromStyles);\n            setStyles(element, toStyles);\n          });\n        }\n      }\n      return;\n    }\n    const playersOnElement = getOrSetDefaultValue(this._engine.playersByElement, element, []);\n    playersOnElement.forEach(player => {\n      if (player.namespaceId == this.id && player.triggerName == triggerName && player.queued) {\n        player.destroy();\n      }\n    });\n    let transition = trigger.matchTransition(fromState.value, toState.value, element, toState.params);\n    let isFallbackTransition = false;\n    if (!transition) {\n      if (!defaultToFallback) return;\n      transition = trigger.fallbackTransition;\n      isFallbackTransition = true;\n    }\n    this._engine.totalQueuedPlayers++;\n    this._queue.push({\n      element,\n      triggerName,\n      transition,\n      fromState,\n      toState,\n      player,\n      isFallbackTransition\n    });\n    if (!isFallbackTransition) {\n      addClass(element, QUEUED_CLASSNAME);\n      player.onStart(() => {\n        removeClass(element, QUEUED_CLASSNAME);\n      });\n    }\n    player.onDone(() => {\n      let index = this.players.indexOf(player);\n      if (index >= 0) {\n        this.players.splice(index, 1);\n      }\n      const players = this._engine.playersByElement.get(element);\n      if (players) {\n        let index = players.indexOf(player);\n        if (index >= 0) {\n          players.splice(index, 1);\n        }\n      }\n    });\n    this.players.push(player);\n    playersOnElement.push(player);\n    return player;\n  }\n  deregister(name) {\n    this._triggers.delete(name);\n    this._engine.statesByElement.forEach(stateMap => stateMap.delete(name));\n    this._elementListeners.forEach((listeners, element) => {\n      this._elementListeners.set(element, listeners.filter(entry => {\n        return entry.name != name;\n      }));\n    });\n  }\n  clearElementCache(element) {\n    this._engine.statesByElement.delete(element);\n    this._elementListeners.delete(element);\n    const elementPlayers = this._engine.playersByElement.get(element);\n    if (elementPlayers) {\n      elementPlayers.forEach(player => player.destroy());\n      this._engine.playersByElement.delete(element);\n    }\n  }\n  _signalRemovalForInnerTriggers(rootElement, context) {\n    const elements = this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true);\n    elements.forEach(elm => {\n      if (elm[REMOVAL_FLAG]) return;\n      const namespaces = this._engine.fetchNamespacesByElement(elm);\n      if (namespaces.size) {\n        namespaces.forEach(ns => ns.triggerLeaveAnimation(elm, context, false, true));\n      } else {\n        this.clearElementCache(elm);\n      }\n    });\n    this._engine.afterFlushAnimationsDone(() => elements.forEach(elm => this.clearElementCache(elm)));\n  }\n  triggerLeaveAnimation(element, context, destroyAfterComplete, defaultToFallback) {\n    const triggerStates = this._engine.statesByElement.get(element);\n    const previousTriggersValues = new Map();\n    if (triggerStates) {\n      const players = [];\n      triggerStates.forEach((state, triggerName) => {\n        previousTriggersValues.set(triggerName, state.value);\n        if (this._triggers.has(triggerName)) {\n          const player = this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);\n          if (player) {\n            players.push(player);\n          }\n        }\n      });\n      if (players.length) {\n        this._engine.markElementAsRemoved(this.id, element, true, context, previousTriggersValues);\n        if (destroyAfterComplete) {\n          optimizeGroupPlayer(players).onDone(() => this._engine.processLeaveNode(element));\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n  prepareLeaveAnimationListeners(element) {\n    const listeners = this._elementListeners.get(element);\n    const elementStates = this._engine.statesByElement.get(element);\n    if (listeners && elementStates) {\n      const visitedTriggers = new Set();\n      listeners.forEach(listener => {\n        const triggerName = listener.name;\n        if (visitedTriggers.has(triggerName)) return;\n        visitedTriggers.add(triggerName);\n        const trigger = this._triggers.get(triggerName);\n        const transition = trigger.fallbackTransition;\n        const fromState = elementStates.get(triggerName) || DEFAULT_STATE_VALUE;\n        const toState = new StateValue(VOID_VALUE);\n        const player = new TransitionAnimationPlayer(this.id, triggerName, element);\n        this._engine.totalQueuedPlayers++;\n        this._queue.push({\n          element,\n          triggerName,\n          transition,\n          fromState,\n          toState,\n          player,\n          isFallbackTransition: true\n        });\n      });\n    }\n  }\n  removeNode(element, context) {\n    const engine = this._engine;\n    if (element.childElementCount) {\n      this._signalRemovalForInnerTriggers(element, context);\n    }\n    if (this.triggerLeaveAnimation(element, context, true)) return;\n    let containsPotentialParentTransition = false;\n    if (engine.totalAnimations) {\n      const currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];\n      if (currentPlayers && currentPlayers.length) {\n        containsPotentialParentTransition = true;\n      } else {\n        let parent = element;\n        while (parent = parent.parentNode) {\n          const triggers = engine.statesByElement.get(parent);\n          if (triggers) {\n            containsPotentialParentTransition = true;\n            break;\n          }\n        }\n      }\n    }\n    this.prepareLeaveAnimationListeners(element);\n    if (containsPotentialParentTransition) {\n      engine.markElementAsRemoved(this.id, element, false, context);\n    } else {\n      const removalFlag = element[REMOVAL_FLAG];\n      if (!removalFlag || removalFlag === NULL_REMOVAL_STATE) {\n        engine.afterFlush(() => this.clearElementCache(element));\n        engine.destroyInnerAnimations(element);\n        engine._onRemovalComplete(element, context);\n      }\n    }\n  }\n  insertNode(element, parent) {\n    addClass(element, this._hostClassName);\n  }\n  drainQueuedTransitions(microtaskId) {\n    const instructions = [];\n    this._queue.forEach(entry => {\n      const player = entry.player;\n      if (player.destroyed) return;\n      const element = entry.element;\n      const listeners = this._elementListeners.get(element);\n      if (listeners) {\n        listeners.forEach(listener => {\n          if (listener.name == entry.triggerName) {\n            const baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);\n            baseEvent['_data'] = microtaskId;\n            listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);\n          }\n        });\n      }\n      if (player.markedForDestroy) {\n        this._engine.afterFlush(() => {\n          player.destroy();\n        });\n      } else {\n        instructions.push(entry);\n      }\n    });\n    this._queue = [];\n    return instructions.sort((a, b) => {\n      const d0 = a.transition.ast.depCount;\n      const d1 = b.transition.ast.depCount;\n      if (d0 == 0 || d1 == 0) {\n        return d0 - d1;\n      }\n      return this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;\n    });\n  }\n  destroy(context) {\n    this.players.forEach(p => p.destroy());\n    this._signalRemovalForInnerTriggers(this.hostElement, context);\n  }\n}\nclass TransitionAnimationEngine {\n  bodyNode;\n  driver;\n  _normalizer;\n  players = [];\n  newHostElements = new Map();\n  playersByElement = new Map();\n  playersByQueriedElement = new Map();\n  statesByElement = new Map();\n  disabledNodes = new Set();\n  totalAnimations = 0;\n  totalQueuedPlayers = 0;\n  _namespaceLookup = {};\n  _namespaceList = [];\n  _flushFns = [];\n  _whenQuietFns = [];\n  namespacesByHostElement = new Map();\n  collectedEnterElements = [];\n  collectedLeaveElements = [];\n  onRemovalComplete = (element, context) => {};\n  _onRemovalComplete(element, context) {\n    this.onRemovalComplete(element, context);\n  }\n  constructor(bodyNode, driver, _normalizer) {\n    this.bodyNode = bodyNode;\n    this.driver = driver;\n    this._normalizer = _normalizer;\n  }\n  get queuedPlayers() {\n    const players = [];\n    this._namespaceList.forEach(ns => {\n      ns.players.forEach(player => {\n        if (player.queued) {\n          players.push(player);\n        }\n      });\n    });\n    return players;\n  }\n  createNamespace(namespaceId, hostElement) {\n    const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);\n    if (this.bodyNode && this.driver.containsElement(this.bodyNode, hostElement)) {\n      this._balanceNamespaceList(ns, hostElement);\n    } else {\n      this.newHostElements.set(hostElement, ns);\n      this.collectEnterElement(hostElement);\n    }\n    return this._namespaceLookup[namespaceId] = ns;\n  }\n  _balanceNamespaceList(ns, hostElement) {\n    const namespaceList = this._namespaceList;\n    const namespacesByHostElement = this.namespacesByHostElement;\n    const limit = namespaceList.length - 1;\n    if (limit >= 0) {\n      let found = false;\n      let ancestor = this.driver.getParentElement(hostElement);\n      while (ancestor) {\n        const ancestorNs = namespacesByHostElement.get(ancestor);\n        if (ancestorNs) {\n          const index = namespaceList.indexOf(ancestorNs);\n          namespaceList.splice(index + 1, 0, ns);\n          found = true;\n          break;\n        }\n        ancestor = this.driver.getParentElement(ancestor);\n      }\n      if (!found) {\n        namespaceList.unshift(ns);\n      }\n    } else {\n      namespaceList.push(ns);\n    }\n    namespacesByHostElement.set(hostElement, ns);\n    return ns;\n  }\n  register(namespaceId, hostElement) {\n    let ns = this._namespaceLookup[namespaceId];\n    if (!ns) {\n      ns = this.createNamespace(namespaceId, hostElement);\n    }\n    return ns;\n  }\n  registerTrigger(namespaceId, name, trigger) {\n    let ns = this._namespaceLookup[namespaceId];\n    if (ns && ns.register(name, trigger)) {\n      this.totalAnimations++;\n    }\n  }\n  destroy(namespaceId, context) {\n    if (!namespaceId) return;\n    this.afterFlush(() => {});\n    this.afterFlushAnimationsDone(() => {\n      const ns = this._fetchNamespace(namespaceId);\n      this.namespacesByHostElement.delete(ns.hostElement);\n      const index = this._namespaceList.indexOf(ns);\n      if (index >= 0) {\n        this._namespaceList.splice(index, 1);\n      }\n      ns.destroy(context);\n      delete this._namespaceLookup[namespaceId];\n    });\n  }\n  _fetchNamespace(id) {\n    return this._namespaceLookup[id];\n  }\n  fetchNamespacesByElement(element) {\n    const namespaces = new Set();\n    const elementStates = this.statesByElement.get(element);\n    if (elementStates) {\n      for (let stateValue of elementStates.values()) {\n        if (stateValue.namespaceId) {\n          const ns = this._fetchNamespace(stateValue.namespaceId);\n          if (ns) {\n            namespaces.add(ns);\n          }\n        }\n      }\n    }\n    return namespaces;\n  }\n  trigger(namespaceId, element, name, value) {\n    if (isElementNode(element)) {\n      const ns = this._fetchNamespace(namespaceId);\n      if (ns) {\n        ns.trigger(element, name, value);\n        return true;\n      }\n    }\n    return false;\n  }\n  insertNode(namespaceId, element, parent, insertBefore) {\n    if (!isElementNode(element)) return;\n    const details = element[REMOVAL_FLAG];\n    if (details && details.setForRemoval) {\n      details.setForRemoval = false;\n      details.setForMove = true;\n      const index = this.collectedLeaveElements.indexOf(element);\n      if (index >= 0) {\n        this.collectedLeaveElements.splice(index, 1);\n      }\n    }\n    if (namespaceId) {\n      const ns = this._fetchNamespace(namespaceId);\n      if (ns) {\n        ns.insertNode(element, parent);\n      }\n    }\n    if (insertBefore) {\n      this.collectEnterElement(element);\n    }\n  }\n  collectEnterElement(element) {\n    this.collectedEnterElements.push(element);\n  }\n  markElementAsDisabled(element, value) {\n    if (value) {\n      if (!this.disabledNodes.has(element)) {\n        this.disabledNodes.add(element);\n        addClass(element, DISABLED_CLASSNAME);\n      }\n    } else if (this.disabledNodes.has(element)) {\n      this.disabledNodes.delete(element);\n      removeClass(element, DISABLED_CLASSNAME);\n    }\n  }\n  removeNode(namespaceId, element, context) {\n    if (isElementNode(element)) {\n      const ns = namespaceId ? this._fetchNamespace(namespaceId) : null;\n      if (ns) {\n        ns.removeNode(element, context);\n      } else {\n        this.markElementAsRemoved(namespaceId, element, false, context);\n      }\n      const hostNS = this.namespacesByHostElement.get(element);\n      if (hostNS && hostNS.id !== namespaceId) {\n        hostNS.removeNode(element, context);\n      }\n    } else {\n      this._onRemovalComplete(element, context);\n    }\n  }\n  markElementAsRemoved(namespaceId, element, hasAnimation, context, previousTriggersValues) {\n    this.collectedLeaveElements.push(element);\n    element[REMOVAL_FLAG] = {\n      namespaceId,\n      setForRemoval: context,\n      hasAnimation,\n      removedBeforeQueried: false,\n      previousTriggersValues\n    };\n  }\n  listen(namespaceId, element, name, phase, callback) {\n    if (isElementNode(element)) {\n      return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);\n    }\n    return () => {};\n  }\n  _buildInstruction(entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {\n    return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);\n  }\n  destroyInnerAnimations(containerElement) {\n    let elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);\n    elements.forEach(element => this.destroyActiveAnimationsForElement(element));\n    if (this.playersByQueriedElement.size == 0) return;\n    elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);\n    elements.forEach(element => this.finishActiveQueriedAnimationOnElement(element));\n  }\n  destroyActiveAnimationsForElement(element) {\n    const players = this.playersByElement.get(element);\n    if (players) {\n      players.forEach(player => {\n        if (player.queued) {\n          player.markedForDestroy = true;\n        } else {\n          player.destroy();\n        }\n      });\n    }\n  }\n  finishActiveQueriedAnimationOnElement(element) {\n    const players = this.playersByQueriedElement.get(element);\n    if (players) {\n      players.forEach(player => player.finish());\n    }\n  }\n  whenRenderingDone() {\n    return new Promise(resolve => {\n      if (this.players.length) {\n        return optimizeGroupPlayer(this.players).onDone(() => resolve());\n      } else {\n        resolve();\n      }\n    });\n  }\n  processLeaveNode(element) {\n    const details = element[REMOVAL_FLAG];\n    if (details && details.setForRemoval) {\n      element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;\n      if (details.namespaceId) {\n        this.destroyInnerAnimations(element);\n        const ns = this._fetchNamespace(details.namespaceId);\n        if (ns) {\n          ns.clearElementCache(element);\n        }\n      }\n      this._onRemovalComplete(element, details.setForRemoval);\n    }\n    if (element.classList?.contains(DISABLED_CLASSNAME)) {\n      this.markElementAsDisabled(element, false);\n    }\n    this.driver.query(element, DISABLED_SELECTOR, true).forEach(node => {\n      this.markElementAsDisabled(node, false);\n    });\n  }\n  flush(microtaskId = -1) {\n    let players = [];\n    if (this.newHostElements.size) {\n      this.newHostElements.forEach((ns, element) => this._balanceNamespaceList(ns, element));\n      this.newHostElements.clear();\n    }\n    if (this.totalAnimations && this.collectedEnterElements.length) {\n      for (let i = 0; i < this.collectedEnterElements.length; i++) {\n        const elm = this.collectedEnterElements[i];\n        addClass(elm, STAR_CLASSNAME);\n      }\n    }\n    if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {\n      const cleanupFns = [];\n      try {\n        players = this._flushAnimations(cleanupFns, microtaskId);\n      } finally {\n        for (let i = 0; i < cleanupFns.length; i++) {\n          cleanupFns[i]();\n        }\n      }\n    } else {\n      for (let i = 0; i < this.collectedLeaveElements.length; i++) {\n        const element = this.collectedLeaveElements[i];\n        this.processLeaveNode(element);\n      }\n    }\n    this.totalQueuedPlayers = 0;\n    this.collectedEnterElements.length = 0;\n    this.collectedLeaveElements.length = 0;\n    this._flushFns.forEach(fn => fn());\n    this._flushFns = [];\n    if (this._whenQuietFns.length) {\n      const quietFns = this._whenQuietFns;\n      this._whenQuietFns = [];\n      if (players.length) {\n        optimizeGroupPlayer(players).onDone(() => {\n          quietFns.forEach(fn => fn());\n        });\n      } else {\n        quietFns.forEach(fn => fn());\n      }\n    }\n  }\n  reportError(errors) {\n    throw triggerTransitionsFailed(errors);\n  }\n  _flushAnimations(cleanupFns, microtaskId) {\n    const subTimelines = new ElementInstructionMap();\n    const skippedPlayers = [];\n    const skippedPlayersMap = new Map();\n    const queuedInstructions = [];\n    const queriedElements = new Map();\n    const allPreStyleElements = new Map();\n    const allPostStyleElements = new Map();\n    const disabledElementsSet = new Set();\n    this.disabledNodes.forEach(node => {\n      disabledElementsSet.add(node);\n      const nodesThatAreDisabled = this.driver.query(node, QUEUED_SELECTOR, true);\n      for (let i = 0; i < nodesThatAreDisabled.length; i++) {\n        disabledElementsSet.add(nodesThatAreDisabled[i]);\n      }\n    });\n    const bodyNode = this.bodyNode;\n    const allTriggerElements = Array.from(this.statesByElement.keys());\n    const enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);\n    const enterNodeMapIds = new Map();\n    let i = 0;\n    enterNodeMap.forEach((nodes, root) => {\n      const className = ENTER_CLASSNAME + i++;\n      enterNodeMapIds.set(root, className);\n      nodes.forEach(node => addClass(node, className));\n    });\n    const allLeaveNodes = [];\n    const mergedLeaveNodes = new Set();\n    const leaveNodesWithoutAnimations = new Set();\n    for (let i = 0; i < this.collectedLeaveElements.length; i++) {\n      const element = this.collectedLeaveElements[i];\n      const details = element[REMOVAL_FLAG];\n      if (details && details.setForRemoval) {\n        allLeaveNodes.push(element);\n        mergedLeaveNodes.add(element);\n        if (details.hasAnimation) {\n          this.driver.query(element, STAR_SELECTOR, true).forEach(elm => mergedLeaveNodes.add(elm));\n        } else {\n          leaveNodesWithoutAnimations.add(element);\n        }\n      }\n    }\n    const leaveNodeMapIds = new Map();\n    const leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));\n    leaveNodeMap.forEach((nodes, root) => {\n      const className = LEAVE_CLASSNAME + i++;\n      leaveNodeMapIds.set(root, className);\n      nodes.forEach(node => addClass(node, className));\n    });\n    cleanupFns.push(() => {\n      enterNodeMap.forEach((nodes, root) => {\n        const className = enterNodeMapIds.get(root);\n        nodes.forEach(node => removeClass(node, className));\n      });\n      leaveNodeMap.forEach((nodes, root) => {\n        const className = leaveNodeMapIds.get(root);\n        nodes.forEach(node => removeClass(node, className));\n      });\n      allLeaveNodes.forEach(element => {\n        this.processLeaveNode(element);\n      });\n    });\n    const allPlayers = [];\n    const erroneousTransitions = [];\n    for (let i = this._namespaceList.length - 1; i >= 0; i--) {\n      const ns = this._namespaceList[i];\n      ns.drainQueuedTransitions(microtaskId).forEach(entry => {\n        const player = entry.player;\n        const element = entry.element;\n        allPlayers.push(player);\n        if (this.collectedEnterElements.length) {\n          const details = element[REMOVAL_FLAG];\n          if (details && details.setForMove) {\n            if (details.previousTriggersValues && details.previousTriggersValues.has(entry.triggerName)) {\n              const previousValue = details.previousTriggersValues.get(entry.triggerName);\n              const triggersWithStates = this.statesByElement.get(entry.element);\n              if (triggersWithStates && triggersWithStates.has(entry.triggerName)) {\n                const state = triggersWithStates.get(entry.triggerName);\n                state.value = previousValue;\n                triggersWithStates.set(entry.triggerName, state);\n              }\n            }\n            player.destroy();\n            return;\n          }\n        }\n        const nodeIsOrphaned = !bodyNode || !this.driver.containsElement(bodyNode, element);\n        const leaveClassName = leaveNodeMapIds.get(element);\n        const enterClassName = enterNodeMapIds.get(element);\n        const instruction = this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned);\n        if (instruction.errors && instruction.errors.length) {\n          erroneousTransitions.push(instruction);\n          return;\n        }\n        if (nodeIsOrphaned) {\n          player.onStart(() => eraseStyles(element, instruction.fromStyles));\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          skippedPlayers.push(player);\n          return;\n        }\n        if (entry.isFallbackTransition) {\n          player.onStart(() => eraseStyles(element, instruction.fromStyles));\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          skippedPlayers.push(player);\n          return;\n        }\n        const timelines = [];\n        instruction.timelines.forEach(tl => {\n          tl.stretchStartingKeyframe = true;\n          if (!this.disabledNodes.has(tl.element)) {\n            timelines.push(tl);\n          }\n        });\n        instruction.timelines = timelines;\n        subTimelines.append(element, instruction.timelines);\n        const tuple = {\n          instruction,\n          player,\n          element\n        };\n        queuedInstructions.push(tuple);\n        instruction.queriedElements.forEach(element => getOrSetDefaultValue(queriedElements, element, []).push(player));\n        instruction.preStyleProps.forEach((stringMap, element) => {\n          if (stringMap.size) {\n            let setVal = allPreStyleElements.get(element);\n            if (!setVal) {\n              allPreStyleElements.set(element, setVal = new Set());\n            }\n            stringMap.forEach((_, prop) => setVal.add(prop));\n          }\n        });\n        instruction.postStyleProps.forEach((stringMap, element) => {\n          let setVal = allPostStyleElements.get(element);\n          if (!setVal) {\n            allPostStyleElements.set(element, setVal = new Set());\n          }\n          stringMap.forEach((_, prop) => setVal.add(prop));\n        });\n      });\n    }\n    if (erroneousTransitions.length) {\n      const errors = [];\n      erroneousTransitions.forEach(instruction => {\n        errors.push(transitionFailed(instruction.triggerName, instruction.errors));\n      });\n      allPlayers.forEach(player => player.destroy());\n      this.reportError(errors);\n    }\n    const allPreviousPlayersMap = new Map();\n    const animationElementMap = new Map();\n    queuedInstructions.forEach(entry => {\n      const element = entry.element;\n      if (subTimelines.has(element)) {\n        animationElementMap.set(element, element);\n        this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);\n      }\n    });\n    skippedPlayers.forEach(player => {\n      const element = player.element;\n      const previousPlayers = this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);\n      previousPlayers.forEach(prevPlayer => {\n        getOrSetDefaultValue(allPreviousPlayersMap, element, []).push(prevPlayer);\n        prevPlayer.destroy();\n      });\n    });\n    const replaceNodes = allLeaveNodes.filter(node => {\n      return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);\n    });\n    const postStylesMap = new Map();\n    const allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, AUTO_STYLE);\n    allLeaveQueriedNodes.forEach(node => {\n      if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {\n        replaceNodes.push(node);\n      }\n    });\n    const preStylesMap = new Map();\n    enterNodeMap.forEach((nodes, root) => {\n      cloakAndComputeStyles(preStylesMap, this.driver, new Set(nodes), allPreStyleElements, _PRE_STYLE);\n    });\n    replaceNodes.forEach(node => {\n      const post = postStylesMap.get(node);\n      const pre = preStylesMap.get(node);\n      postStylesMap.set(node, new Map([...(post?.entries() ?? []), ...(pre?.entries() ?? [])]));\n    });\n    const rootPlayers = [];\n    const subPlayers = [];\n    const NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};\n    queuedInstructions.forEach(entry => {\n      const {\n        element,\n        player,\n        instruction\n      } = entry;\n      if (subTimelines.has(element)) {\n        if (disabledElementsSet.has(element)) {\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          player.disabled = true;\n          player.overrideTotalTime(instruction.totalTime);\n          skippedPlayers.push(player);\n          return;\n        }\n        let parentWithAnimation = NO_PARENT_ANIMATION_ELEMENT_DETECTED;\n        if (animationElementMap.size > 1) {\n          let elm = element;\n          const parentsToAdd = [];\n          while (elm = elm.parentNode) {\n            const detectedParent = animationElementMap.get(elm);\n            if (detectedParent) {\n              parentWithAnimation = detectedParent;\n              break;\n            }\n            parentsToAdd.push(elm);\n          }\n          parentsToAdd.forEach(parent => animationElementMap.set(parent, parentWithAnimation));\n        }\n        const innerPlayer = this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);\n        player.setRealPlayer(innerPlayer);\n        if (parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {\n          rootPlayers.push(player);\n        } else {\n          const parentPlayers = this.playersByElement.get(parentWithAnimation);\n          if (parentPlayers && parentPlayers.length) {\n            player.parentPlayer = optimizeGroupPlayer(parentPlayers);\n          }\n          skippedPlayers.push(player);\n        }\n      } else {\n        eraseStyles(element, instruction.fromStyles);\n        player.onDestroy(() => setStyles(element, instruction.toStyles));\n        subPlayers.push(player);\n        if (disabledElementsSet.has(element)) {\n          skippedPlayers.push(player);\n        }\n      }\n    });\n    subPlayers.forEach(player => {\n      const playersForElement = skippedPlayersMap.get(player.element);\n      if (playersForElement && playersForElement.length) {\n        const innerPlayer = optimizeGroupPlayer(playersForElement);\n        player.setRealPlayer(innerPlayer);\n      }\n    });\n    skippedPlayers.forEach(player => {\n      if (player.parentPlayer) {\n        player.syncPlayerEvents(player.parentPlayer);\n      } else {\n        player.destroy();\n      }\n    });\n    for (let i = 0; i < allLeaveNodes.length; i++) {\n      const element = allLeaveNodes[i];\n      const details = element[REMOVAL_FLAG];\n      removeClass(element, LEAVE_CLASSNAME);\n      if (details && details.hasAnimation) continue;\n      let players = [];\n      if (queriedElements.size) {\n        let queriedPlayerResults = queriedElements.get(element);\n        if (queriedPlayerResults && queriedPlayerResults.length) {\n          players.push(...queriedPlayerResults);\n        }\n        let queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);\n        for (let j = 0; j < queriedInnerElements.length; j++) {\n          let queriedPlayers = queriedElements.get(queriedInnerElements[j]);\n          if (queriedPlayers && queriedPlayers.length) {\n            players.push(...queriedPlayers);\n          }\n        }\n      }\n      const activePlayers = players.filter(p => !p.destroyed);\n      if (activePlayers.length) {\n        removeNodesAfterAnimationDone(this, element, activePlayers);\n      } else {\n        this.processLeaveNode(element);\n      }\n    }\n    allLeaveNodes.length = 0;\n    rootPlayers.forEach(player => {\n      this.players.push(player);\n      player.onDone(() => {\n        player.destroy();\n        const index = this.players.indexOf(player);\n        this.players.splice(index, 1);\n      });\n      player.play();\n    });\n    return rootPlayers;\n  }\n  afterFlush(callback) {\n    this._flushFns.push(callback);\n  }\n  afterFlushAnimationsDone(callback) {\n    this._whenQuietFns.push(callback);\n  }\n  _getPreviousPlayers(element, isQueriedElement, namespaceId, triggerName, toStateValue) {\n    let players = [];\n    if (isQueriedElement) {\n      const queriedElementPlayers = this.playersByQueriedElement.get(element);\n      if (queriedElementPlayers) {\n        players = queriedElementPlayers;\n      }\n    } else {\n      const elementPlayers = this.playersByElement.get(element);\n      if (elementPlayers) {\n        const isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;\n        elementPlayers.forEach(player => {\n          if (player.queued) return;\n          if (!isRemovalAnimation && player.triggerName != triggerName) return;\n          players.push(player);\n        });\n      }\n    }\n    if (namespaceId || triggerName) {\n      players = players.filter(player => {\n        if (namespaceId && namespaceId != player.namespaceId) return false;\n        if (triggerName && triggerName != player.triggerName) return false;\n        return true;\n      });\n    }\n    return players;\n  }\n  _beforeAnimationBuild(namespaceId, instruction, allPreviousPlayersMap) {\n    const triggerName = instruction.triggerName;\n    const rootElement = instruction.element;\n    const targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;\n    const targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;\n    for (const timelineInstruction of instruction.timelines) {\n      const element = timelineInstruction.element;\n      const isQueriedElement = element !== rootElement;\n      const players = getOrSetDefaultValue(allPreviousPlayersMap, element, []);\n      const previousPlayers = this._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);\n      previousPlayers.forEach(player => {\n        const realPlayer = player.getRealPlayer();\n        if (realPlayer.beforeDestroy) {\n          realPlayer.beforeDestroy();\n        }\n        player.destroy();\n        players.push(player);\n      });\n    }\n    eraseStyles(rootElement, instruction.fromStyles);\n  }\n  _buildAnimation(namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {\n    const triggerName = instruction.triggerName;\n    const rootElement = instruction.element;\n    const allQueriedPlayers = [];\n    const allConsumedElements = new Set();\n    const allSubElements = new Set();\n    const allNewPlayers = instruction.timelines.map(timelineInstruction => {\n      const element = timelineInstruction.element;\n      allConsumedElements.add(element);\n      const details = element[REMOVAL_FLAG];\n      if (details && details.removedBeforeQueried) return new NoopAnimationPlayer(timelineInstruction.duration, timelineInstruction.delay);\n      const isQueriedElement = element !== rootElement;\n      const previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY).map(p => p.getRealPlayer())).filter(p => {\n        const pp = p;\n        return pp.element ? pp.element === element : false;\n      });\n      const preStyles = preStylesMap.get(element);\n      const postStyles = postStylesMap.get(element);\n      const keyframes = normalizeKeyframes(this._normalizer, timelineInstruction.keyframes, preStyles, postStyles);\n      const player = this._buildPlayer(timelineInstruction, keyframes, previousPlayers);\n      if (timelineInstruction.subTimeline && skippedPlayersMap) {\n        allSubElements.add(element);\n      }\n      if (isQueriedElement) {\n        const wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);\n        wrappedPlayer.setRealPlayer(player);\n        allQueriedPlayers.push(wrappedPlayer);\n      }\n      return player;\n    });\n    allQueriedPlayers.forEach(player => {\n      getOrSetDefaultValue(this.playersByQueriedElement, player.element, []).push(player);\n      player.onDone(() => deleteOrUnsetInMap(this.playersByQueriedElement, player.element, player));\n    });\n    allConsumedElements.forEach(element => addClass(element, NG_ANIMATING_CLASSNAME));\n    const player = optimizeGroupPlayer(allNewPlayers);\n    player.onDestroy(() => {\n      allConsumedElements.forEach(element => removeClass(element, NG_ANIMATING_CLASSNAME));\n      setStyles(rootElement, instruction.toStyles);\n    });\n    allSubElements.forEach(element => {\n      getOrSetDefaultValue(skippedPlayersMap, element, []).push(player);\n    });\n    return player;\n  }\n  _buildPlayer(instruction, keyframes, previousPlayers) {\n    if (keyframes.length > 0) {\n      return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);\n    }\n    return new NoopAnimationPlayer(instruction.duration, instruction.delay);\n  }\n}\nclass TransitionAnimationPlayer {\n  namespaceId;\n  triggerName;\n  element;\n  _player = new NoopAnimationPlayer();\n  _containsRealPlayer = false;\n  _queuedCallbacks = new Map();\n  destroyed = false;\n  parentPlayer = null;\n  markedForDestroy = false;\n  disabled = false;\n  queued = true;\n  totalTime = 0;\n  constructor(namespaceId, triggerName, element) {\n    this.namespaceId = namespaceId;\n    this.triggerName = triggerName;\n    this.element = element;\n  }\n  setRealPlayer(player) {\n    if (this._containsRealPlayer) return;\n    this._player = player;\n    this._queuedCallbacks.forEach((callbacks, phase) => {\n      callbacks.forEach(callback => listenOnPlayer(player, phase, undefined, callback));\n    });\n    this._queuedCallbacks.clear();\n    this._containsRealPlayer = true;\n    this.overrideTotalTime(player.totalTime);\n    this.queued = false;\n  }\n  getRealPlayer() {\n    return this._player;\n  }\n  overrideTotalTime(totalTime) {\n    this.totalTime = totalTime;\n  }\n  syncPlayerEvents(player) {\n    const p = this._player;\n    if (p.triggerCallback) {\n      player.onStart(() => p.triggerCallback('start'));\n    }\n    player.onDone(() => this.finish());\n    player.onDestroy(() => this.destroy());\n  }\n  _queueEvent(name, callback) {\n    getOrSetDefaultValue(this._queuedCallbacks, name, []).push(callback);\n  }\n  onDone(fn) {\n    if (this.queued) {\n      this._queueEvent('done', fn);\n    }\n    this._player.onDone(fn);\n  }\n  onStart(fn) {\n    if (this.queued) {\n      this._queueEvent('start', fn);\n    }\n    this._player.onStart(fn);\n  }\n  onDestroy(fn) {\n    if (this.queued) {\n      this._queueEvent('destroy', fn);\n    }\n    this._player.onDestroy(fn);\n  }\n  init() {\n    this._player.init();\n  }\n  hasStarted() {\n    return this.queued ? false : this._player.hasStarted();\n  }\n  play() {\n    !this.queued && this._player.play();\n  }\n  pause() {\n    !this.queued && this._player.pause();\n  }\n  restart() {\n    !this.queued && this._player.restart();\n  }\n  finish() {\n    this._player.finish();\n  }\n  destroy() {\n    this.destroyed = true;\n    this._player.destroy();\n  }\n  reset() {\n    !this.queued && this._player.reset();\n  }\n  setPosition(p) {\n    if (!this.queued) {\n      this._player.setPosition(p);\n    }\n  }\n  getPosition() {\n    return this.queued ? 0 : this._player.getPosition();\n  }\n  triggerCallback(phaseName) {\n    const p = this._player;\n    if (p.triggerCallback) {\n      p.triggerCallback(phaseName);\n    }\n  }\n}\nfunction deleteOrUnsetInMap(map, key, value) {\n  let currentValues = map.get(key);\n  if (currentValues) {\n    if (currentValues.length) {\n      const index = currentValues.indexOf(value);\n      currentValues.splice(index, 1);\n    }\n    if (currentValues.length == 0) {\n      map.delete(key);\n    }\n  }\n  return currentValues;\n}\nfunction normalizeTriggerValue(value) {\n  return value != null ? value : null;\n}\nfunction isElementNode(node) {\n  return node && node['nodeType'] === 1;\n}\nfunction isTriggerEventValid(eventName) {\n  return eventName == 'start' || eventName == 'done';\n}\nfunction cloakElement(element, value) {\n  const oldValue = element.style.display;\n  element.style.display = value != null ? value : 'none';\n  return oldValue;\n}\nfunction cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {\n  const cloakVals = [];\n  elements.forEach(element => cloakVals.push(cloakElement(element)));\n  const failedElements = [];\n  elementPropsMap.forEach((props, element) => {\n    const styles = new Map();\n    props.forEach(prop => {\n      const value = driver.computeStyle(element, prop, defaultStyle);\n      styles.set(prop, value);\n      if (!value || value.length == 0) {\n        element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;\n        failedElements.push(element);\n      }\n    });\n    valuesMap.set(element, styles);\n  });\n  let i = 0;\n  elements.forEach(element => cloakElement(element, cloakVals[i++]));\n  return failedElements;\n}\nfunction buildRootMap(roots, nodes) {\n  const rootMap = new Map();\n  roots.forEach(root => rootMap.set(root, []));\n  if (nodes.length == 0) return rootMap;\n  const NULL_NODE = 1;\n  const nodeSet = new Set(nodes);\n  const localRootMap = new Map();\n  function getRoot(node) {\n    if (!node) return NULL_NODE;\n    let root = localRootMap.get(node);\n    if (root) return root;\n    const parent = node.parentNode;\n    if (rootMap.has(parent)) {\n      root = parent;\n    } else if (nodeSet.has(parent)) {\n      root = NULL_NODE;\n    } else {\n      root = getRoot(parent);\n    }\n    localRootMap.set(node, root);\n    return root;\n  }\n  nodes.forEach(node => {\n    const root = getRoot(node);\n    if (root !== NULL_NODE) {\n      rootMap.get(root).push(node);\n    }\n  });\n  return rootMap;\n}\nfunction addClass(element, className) {\n  element.classList?.add(className);\n}\nfunction removeClass(element, className) {\n  element.classList?.remove(className);\n}\nfunction removeNodesAfterAnimationDone(engine, element, players) {\n  optimizeGroupPlayer(players).onDone(() => engine.processLeaveNode(element));\n}\nfunction flattenGroupPlayers(players) {\n  const finalPlayers = [];\n  _flattenGroupPlayersRecur(players, finalPlayers);\n  return finalPlayers;\n}\nfunction _flattenGroupPlayersRecur(players, finalPlayers) {\n  for (let i = 0; i < players.length; i++) {\n    const player = players[i];\n    if (player instanceof AnimationGroupPlayer) {\n      _flattenGroupPlayersRecur(player.players, finalPlayers);\n    } else {\n      finalPlayers.push(player);\n    }\n  }\n}\nfunction objEquals(a, b) {\n  const k1 = Object.keys(a);\n  const k2 = Object.keys(b);\n  if (k1.length != k2.length) return false;\n  for (let i = 0; i < k1.length; i++) {\n    const prop = k1[i];\n    if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return false;\n  }\n  return true;\n}\nfunction replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {\n  const postEntry = allPostStyleElements.get(element);\n  if (!postEntry) return false;\n  let preEntry = allPreStyleElements.get(element);\n  if (preEntry) {\n    postEntry.forEach(data => preEntry.add(data));\n  } else {\n    allPreStyleElements.set(element, postEntry);\n  }\n  allPostStyleElements.delete(element);\n  return true;\n}\n\nclass AnimationEngine {\n  _driver;\n  _normalizer;\n  _transitionEngine;\n  _timelineEngine;\n  _triggerCache = {};\n  onRemovalComplete = (element, context) => {};\n  constructor(doc, _driver, _normalizer) {\n    this._driver = _driver;\n    this._normalizer = _normalizer;\n    this._transitionEngine = new TransitionAnimationEngine(doc.body, _driver, _normalizer);\n    this._timelineEngine = new TimelineAnimationEngine(doc.body, _driver, _normalizer);\n    this._transitionEngine.onRemovalComplete = (element, context) => this.onRemovalComplete(element, context);\n  }\n  registerTrigger(componentId, namespaceId, hostElement, name, metadata) {\n    const cacheKey = componentId + '-' + name;\n    let trigger = this._triggerCache[cacheKey];\n    if (!trigger) {\n      const errors = [];\n      const warnings = [];\n      const ast = buildAnimationAst(this._driver, metadata, errors, warnings);\n      if (errors.length) {\n        throw triggerBuildFailed(name, errors);\n      }\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (warnings.length) {\n          warnTriggerBuild(name, warnings);\n        }\n      }\n      trigger = buildTrigger(name, ast, this._normalizer);\n      this._triggerCache[cacheKey] = trigger;\n    }\n    this._transitionEngine.registerTrigger(namespaceId, name, trigger);\n  }\n  register(namespaceId, hostElement) {\n    this._transitionEngine.register(namespaceId, hostElement);\n  }\n  destroy(namespaceId, context) {\n    this._transitionEngine.destroy(namespaceId, context);\n  }\n  onInsert(namespaceId, element, parent, insertBefore) {\n    this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);\n  }\n  onRemove(namespaceId, element, context) {\n    this._transitionEngine.removeNode(namespaceId, element, context);\n  }\n  disableAnimations(element, disable) {\n    this._transitionEngine.markElementAsDisabled(element, disable);\n  }\n  process(namespaceId, element, property, value) {\n    if (property.charAt(0) == '@') {\n      const [id, action] = parseTimelineCommand(property);\n      const args = value;\n      this._timelineEngine.command(id, element, action, args);\n    } else {\n      this._transitionEngine.trigger(namespaceId, element, property, value);\n    }\n  }\n  listen(namespaceId, element, eventName, eventPhase, callback) {\n    if (eventName.charAt(0) == '@') {\n      const [id, action] = parseTimelineCommand(eventName);\n      return this._timelineEngine.listen(id, element, action, callback);\n    }\n    return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);\n  }\n  flush(microtaskId = -1) {\n    this._transitionEngine.flush(microtaskId);\n  }\n  get players() {\n    return [...this._transitionEngine.players, ...this._timelineEngine.players];\n  }\n  whenRenderingDone() {\n    return this._transitionEngine.whenRenderingDone();\n  }\n  afterFlushAnimationsDone(cb) {\n    this._transitionEngine.afterFlushAnimationsDone(cb);\n  }\n}\n\nfunction packageNonAnimatableStyles(element, styles) {\n  let startStyles = null;\n  let endStyles = null;\n  if (Array.isArray(styles) && styles.length) {\n    startStyles = filterNonAnimatableStyles(styles[0]);\n    if (styles.length > 1) {\n      endStyles = filterNonAnimatableStyles(styles[styles.length - 1]);\n    }\n  } else if (styles instanceof Map) {\n    startStyles = filterNonAnimatableStyles(styles);\n  }\n  return startStyles || endStyles ? new SpecialCasedStyles(element, startStyles, endStyles) : null;\n}\nclass SpecialCasedStyles {\n  _element;\n  _startStyles;\n  _endStyles;\n  static initialStylesByElement = /* @__PURE__ */new WeakMap();\n  _state = 0;\n  _initialStyles;\n  constructor(_element, _startStyles, _endStyles) {\n    this._element = _element;\n    this._startStyles = _startStyles;\n    this._endStyles = _endStyles;\n    let initialStyles = SpecialCasedStyles.initialStylesByElement.get(_element);\n    if (!initialStyles) {\n      SpecialCasedStyles.initialStylesByElement.set(_element, initialStyles = new Map());\n    }\n    this._initialStyles = initialStyles;\n  }\n  start() {\n    if (this._state < 1) {\n      if (this._startStyles) {\n        setStyles(this._element, this._startStyles, this._initialStyles);\n      }\n      this._state = 1;\n    }\n  }\n  finish() {\n    this.start();\n    if (this._state < 2) {\n      setStyles(this._element, this._initialStyles);\n      if (this._endStyles) {\n        setStyles(this._element, this._endStyles);\n        this._endStyles = null;\n      }\n      this._state = 1;\n    }\n  }\n  destroy() {\n    this.finish();\n    if (this._state < 3) {\n      SpecialCasedStyles.initialStylesByElement.delete(this._element);\n      if (this._startStyles) {\n        eraseStyles(this._element, this._startStyles);\n        this._endStyles = null;\n      }\n      if (this._endStyles) {\n        eraseStyles(this._element, this._endStyles);\n        this._endStyles = null;\n      }\n      setStyles(this._element, this._initialStyles);\n      this._state = 3;\n    }\n  }\n}\nfunction filterNonAnimatableStyles(styles) {\n  let result = null;\n  styles.forEach((val, prop) => {\n    if (isNonAnimatableStyle(prop)) {\n      result = result || new Map();\n      result.set(prop, val);\n    }\n  });\n  return result;\n}\nfunction isNonAnimatableStyle(prop) {\n  return prop === 'display' || prop === 'position';\n}\n\nclass WebAnimationsPlayer {\n  element;\n  keyframes;\n  options;\n  _specialStyles;\n  _onDoneFns = [];\n  _onStartFns = [];\n  _onDestroyFns = [];\n  _duration;\n  _delay;\n  _initialized = false;\n  _finished = false;\n  _started = false;\n  _destroyed = false;\n  _finalKeyframe;\n  _originalOnDoneFns = [];\n  _originalOnStartFns = [];\n  domPlayer = null;\n  time = 0;\n  parentPlayer = null;\n  currentSnapshot = new Map();\n  constructor(element, keyframes, options, _specialStyles) {\n    this.element = element;\n    this.keyframes = keyframes;\n    this.options = options;\n    this._specialStyles = _specialStyles;\n    this._duration = options['duration'];\n    this._delay = options['delay'] || 0;\n    this.time = this._duration + this._delay;\n  }\n  _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n  init() {\n    if (!this._buildPlayer()) {\n      return;\n    }\n    this._preparePlayerBeforeStart();\n  }\n  _buildPlayer() {\n    if (this._initialized) return this.domPlayer;\n    this._initialized = true;\n    const keyframes = this.keyframes;\n    const animation = this._triggerWebAnimation(this.element, keyframes, this.options);\n    if (!animation) {\n      this._onFinish();\n      return null;\n    }\n    this.domPlayer = animation;\n    this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : new Map();\n    const onFinish = () => this._onFinish();\n    animation.addEventListener('finish', onFinish);\n    this.onDestroy(() => {\n      animation.removeEventListener('finish', onFinish);\n    });\n    return animation;\n  }\n  _preparePlayerBeforeStart() {\n    if (this._delay) {\n      this._resetDomPlayerState();\n    } else {\n      this.domPlayer?.pause();\n    }\n  }\n  _convertKeyframesToObject(keyframes) {\n    const kfs = [];\n    keyframes.forEach(frame => {\n      kfs.push(Object.fromEntries(frame));\n    });\n    return kfs;\n  }\n  _triggerWebAnimation(element, keyframes, options) {\n    const keyframesObject = this._convertKeyframesToObject(keyframes);\n    try {\n      return element.animate(keyframesObject, options);\n    } catch {\n      return null;\n    }\n  }\n  onStart(fn) {\n    this._originalOnStartFns.push(fn);\n    this._onStartFns.push(fn);\n  }\n  onDone(fn) {\n    this._originalOnDoneFns.push(fn);\n    this._onDoneFns.push(fn);\n  }\n  onDestroy(fn) {\n    this._onDestroyFns.push(fn);\n  }\n  play() {\n    const player = this._buildPlayer();\n    if (!player) {\n      return;\n    }\n    if (!this.hasStarted()) {\n      this._onStartFns.forEach(fn => fn());\n      this._onStartFns = [];\n      this._started = true;\n      if (this._specialStyles) {\n        this._specialStyles.start();\n      }\n    }\n    player.play();\n  }\n  pause() {\n    this.init();\n    this.domPlayer?.pause();\n  }\n  finish() {\n    this.init();\n    if (!this.domPlayer) return;\n    if (this._specialStyles) {\n      this._specialStyles.finish();\n    }\n    this._onFinish();\n    this.domPlayer.finish();\n  }\n  reset() {\n    this._resetDomPlayerState();\n    this._destroyed = false;\n    this._finished = false;\n    this._started = false;\n    this._onStartFns = this._originalOnStartFns;\n    this._onDoneFns = this._originalOnDoneFns;\n  }\n  _resetDomPlayerState() {\n    this.domPlayer?.cancel();\n  }\n  restart() {\n    this.reset();\n    this.play();\n  }\n  hasStarted() {\n    return this._started;\n  }\n  destroy() {\n    if (!this._destroyed) {\n      this._destroyed = true;\n      this._resetDomPlayerState();\n      this._onFinish();\n      if (this._specialStyles) {\n        this._specialStyles.destroy();\n      }\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n  setPosition(p) {\n    if (!this.domPlayer) {\n      this.init();\n    }\n    if (this.domPlayer) {\n      this.domPlayer.currentTime = p * this.time;\n    }\n  }\n  getPosition() {\n    if (!this.domPlayer) {\n      return this._initialized ? 1 : 0;\n    }\n    return +(this.domPlayer.currentTime ?? 0) / this.time;\n  }\n  get totalTime() {\n    return this._delay + this._duration;\n  }\n  beforeDestroy() {\n    const styles = new Map();\n    if (this.hasStarted()) {\n      const finalKeyframe = this._finalKeyframe;\n      finalKeyframe.forEach((val, prop) => {\n        if (prop !== 'offset') {\n          styles.set(prop, this._finished ? val : computeStyle(this.element, prop));\n        }\n      });\n    }\n    this.currentSnapshot = styles;\n  }\n  triggerCallback(phaseName) {\n    const methods = phaseName === 'start' ? this._onStartFns : this._onDoneFns;\n    methods.forEach(fn => fn());\n    methods.length = 0;\n  }\n}\n\nclass WebAnimationsDriver {\n  validateStyleProperty(prop) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      return validateStyleProperty(prop);\n    }\n    return true;\n  }\n  validateAnimatableStyleProperty(prop) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const cssProp = camelCaseToDashCase(prop);\n      return validateWebAnimatableStyleProperty(cssProp);\n    }\n    return true;\n  }\n  containsElement(elm1, elm2) {\n    return containsElement(elm1, elm2);\n  }\n  getParentElement(element) {\n    return getParentElement(element);\n  }\n  query(element, selector, multi) {\n    return invokeQuery(element, selector, multi);\n  }\n  computeStyle(element, prop, defaultValue) {\n    return computeStyle(element, prop);\n  }\n  animate(element, keyframes, duration, delay, easing, previousPlayers = []) {\n    const fill = delay == 0 ? 'both' : 'forwards';\n    const playerOptions = {\n      duration,\n      delay,\n      fill\n    };\n    if (easing) {\n      playerOptions['easing'] = easing;\n    }\n    const previousStyles = new Map();\n    const previousWebAnimationPlayers = previousPlayers.filter(player => player instanceof WebAnimationsPlayer);\n    if (allowPreviousPlayerStylesMerge(duration, delay)) {\n      previousWebAnimationPlayers.forEach(player => {\n        player.currentSnapshot.forEach((val, prop) => previousStyles.set(prop, val));\n      });\n    }\n    let _keyframes = normalizeKeyframes$1(keyframes).map(styles => new Map(styles));\n    _keyframes = balancePreviousStylesIntoKeyframes(element, _keyframes, previousStyles);\n    const specialStyles = packageNonAnimatableStyles(element, _keyframes);\n    return new WebAnimationsPlayer(element, _keyframes, playerOptions, specialStyles);\n  }\n}\n\nfunction createEngine(type, doc) {\n  if (type === 'noop') {\n    return new AnimationEngine(doc, new NoopAnimationDriver(), new NoopAnimationStyleNormalizer());\n  }\n  return new AnimationEngine(doc, new WebAnimationsDriver(), new WebAnimationsStyleNormalizer());\n}\n\nclass Animation {\n  _driver;\n  _animationAst;\n  constructor(_driver, input) {\n    this._driver = _driver;\n    const errors = [];\n    const warnings = [];\n    const ast = buildAnimationAst(_driver, input, errors, warnings);\n    if (errors.length) {\n      throw validationFailed(errors);\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (warnings.length) {\n        warnValidation(warnings);\n      }\n    }\n    this._animationAst = ast;\n  }\n  buildTimelines(element, startingStyles, destinationStyles, options, subInstructions) {\n    const start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : startingStyles;\n    const dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : destinationStyles;\n    const errors = [];\n    subInstructions = subInstructions || new ElementInstructionMap();\n    const result = buildAnimationTimelines(this._driver, element, this._animationAst, ENTER_CLASSNAME, LEAVE_CLASSNAME, start, dest, options, subInstructions, errors);\n    if (errors.length) {\n      throw buildingFailed(errors);\n    }\n    return result;\n  }\n}\n\nconst ANIMATION_PREFIX = '@';\nconst DISABLE_ANIMATIONS_FLAG = '@.disabled';\nclass BaseAnimationRenderer {\n  namespaceId;\n  delegate;\n  engine;\n  _onDestroy;\n  ɵtype = 0;\n  constructor(namespaceId, delegate, engine, _onDestroy) {\n    this.namespaceId = namespaceId;\n    this.delegate = delegate;\n    this.engine = engine;\n    this._onDestroy = _onDestroy;\n  }\n  get data() {\n    return this.delegate.data;\n  }\n  destroyNode(node) {\n    this.delegate.destroyNode?.(node);\n  }\n  destroy() {\n    this.engine.destroy(this.namespaceId, this.delegate);\n    this.engine.afterFlushAnimationsDone(() => {\n      queueMicrotask(() => {\n        this.delegate.destroy();\n      });\n    });\n    this._onDestroy?.();\n  }\n  createElement(name, namespace) {\n    return this.delegate.createElement(name, namespace);\n  }\n  createComment(value) {\n    return this.delegate.createComment(value);\n  }\n  createText(value) {\n    return this.delegate.createText(value);\n  }\n  appendChild(parent, newChild) {\n    this.delegate.appendChild(parent, newChild);\n    this.engine.onInsert(this.namespaceId, newChild, parent, false);\n  }\n  insertBefore(parent, newChild, refChild, isMove = true) {\n    this.delegate.insertBefore(parent, newChild, refChild);\n    this.engine.onInsert(this.namespaceId, newChild, parent, isMove);\n  }\n  removeChild(parent, oldChild, isHostElement, requireSynchronousElementRemoval) {\n    if (requireSynchronousElementRemoval) {\n      this.delegate.removeChild(parent, oldChild, isHostElement, requireSynchronousElementRemoval);\n      return;\n    }\n    if (this.parentNode(oldChild)) {\n      this.engine.onRemove(this.namespaceId, oldChild, this.delegate);\n    }\n  }\n  selectRootElement(selectorOrNode, preserveContent) {\n    return this.delegate.selectRootElement(selectorOrNode, preserveContent);\n  }\n  parentNode(node) {\n    return this.delegate.parentNode(node);\n  }\n  nextSibling(node) {\n    return this.delegate.nextSibling(node);\n  }\n  setAttribute(el, name, value, namespace) {\n    this.delegate.setAttribute(el, name, value, namespace);\n  }\n  removeAttribute(el, name, namespace) {\n    this.delegate.removeAttribute(el, name, namespace);\n  }\n  addClass(el, name) {\n    this.delegate.addClass(el, name);\n  }\n  removeClass(el, name) {\n    this.delegate.removeClass(el, name);\n  }\n  setStyle(el, style, value, flags) {\n    this.delegate.setStyle(el, style, value, flags);\n  }\n  removeStyle(el, style, flags) {\n    this.delegate.removeStyle(el, style, flags);\n  }\n  setProperty(el, name, value) {\n    if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {\n      this.disableAnimations(el, !!value);\n    } else {\n      this.delegate.setProperty(el, name, value);\n    }\n  }\n  setValue(node, value) {\n    this.delegate.setValue(node, value);\n  }\n  listen(target, eventName, callback, options) {\n    return this.delegate.listen(target, eventName, callback, options);\n  }\n  disableAnimations(element, value) {\n    this.engine.disableAnimations(element, value);\n  }\n}\nclass AnimationRenderer extends BaseAnimationRenderer {\n  factory;\n  constructor(factory, namespaceId, delegate, engine, onDestroy) {\n    super(namespaceId, delegate, engine, onDestroy);\n    this.factory = factory;\n    this.namespaceId = namespaceId;\n  }\n  setProperty(el, name, value) {\n    if (name.charAt(0) == ANIMATION_PREFIX) {\n      if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {\n        value = value === undefined ? true : !!value;\n        this.disableAnimations(el, value);\n      } else {\n        this.engine.process(this.namespaceId, el, name.slice(1), value);\n      }\n    } else {\n      this.delegate.setProperty(el, name, value);\n    }\n  }\n  listen(target, eventName, callback, options) {\n    if (eventName.charAt(0) == ANIMATION_PREFIX) {\n      const element = resolveElementFromTarget(target);\n      let name = eventName.slice(1);\n      let phase = '';\n      if (name.charAt(0) != ANIMATION_PREFIX) {\n        [name, phase] = parseTriggerCallbackName(name);\n      }\n      return this.engine.listen(this.namespaceId, element, name, phase, event => {\n        const countId = event['_data'] || -1;\n        this.factory.scheduleListenerCallback(countId, callback, event);\n      });\n    }\n    return this.delegate.listen(target, eventName, callback, options);\n  }\n}\nfunction resolveElementFromTarget(target) {\n  switch (target) {\n    case 'body':\n      return document.body;\n    case 'document':\n      return document;\n    case 'window':\n      return window;\n    default:\n      return target;\n  }\n}\nfunction parseTriggerCallbackName(triggerName) {\n  const dotIndex = triggerName.indexOf('.');\n  const trigger = triggerName.substring(0, dotIndex);\n  const phase = triggerName.slice(dotIndex + 1);\n  return [trigger, phase];\n}\n\nclass AnimationRendererFactory {\n  delegate;\n  engine;\n  _zone;\n  _currentId = 0;\n  _microtaskId = 1;\n  _animationCallbacksBuffer = [];\n  _rendererCache = new Map();\n  _cdRecurDepth = 0;\n  constructor(delegate, engine, _zone) {\n    this.delegate = delegate;\n    this.engine = engine;\n    this._zone = _zone;\n    engine.onRemovalComplete = (element, delegate) => {\n      delegate?.removeChild(null, element);\n    };\n  }\n  createRenderer(hostElement, type) {\n    const EMPTY_NAMESPACE_ID = '';\n    const delegate = this.delegate.createRenderer(hostElement, type);\n    if (!hostElement || !type?.data?.['animation']) {\n      const cache = this._rendererCache;\n      let renderer = cache.get(delegate);\n      if (!renderer) {\n        const onRendererDestroy = () => cache.delete(delegate);\n        renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine, onRendererDestroy);\n        cache.set(delegate, renderer);\n      }\n      return renderer;\n    }\n    const componentId = type.id;\n    const namespaceId = type.id + '-' + this._currentId;\n    this._currentId++;\n    this.engine.register(namespaceId, hostElement);\n    const registerTrigger = trigger => {\n      if (Array.isArray(trigger)) {\n        trigger.forEach(registerTrigger);\n      } else {\n        this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger);\n      }\n    };\n    const animationTriggers = type.data['animation'];\n    animationTriggers.forEach(registerTrigger);\n    return new AnimationRenderer(this, namespaceId, delegate, this.engine);\n  }\n  begin() {\n    this._cdRecurDepth++;\n    if (this.delegate.begin) {\n      this.delegate.begin();\n    }\n  }\n  _scheduleCountTask() {\n    queueMicrotask(() => {\n      this._microtaskId++;\n    });\n  }\n  scheduleListenerCallback(count, fn, data) {\n    if (count >= 0 && count < this._microtaskId) {\n      this._zone.run(() => fn(data));\n      return;\n    }\n    const animationCallbacksBuffer = this._animationCallbacksBuffer;\n    if (animationCallbacksBuffer.length == 0) {\n      queueMicrotask(() => {\n        this._zone.run(() => {\n          animationCallbacksBuffer.forEach(tuple => {\n            const [fn, data] = tuple;\n            fn(data);\n          });\n          this._animationCallbacksBuffer = [];\n        });\n      });\n    }\n    animationCallbacksBuffer.push([fn, data]);\n  }\n  end() {\n    this._cdRecurDepth--;\n    if (this._cdRecurDepth == 0) {\n      this._zone.runOutsideAngular(() => {\n        this._scheduleCountTask();\n        this.engine.flush(this._microtaskId);\n      });\n    }\n    if (this.delegate.end) {\n      this.delegate.end();\n    }\n  }\n  whenRenderingDone() {\n    return this.engine.whenRenderingDone();\n  }\n  componentReplaced(componentId) {\n    this.engine.flush();\n    this.delegate.componentReplaced?.(componentId);\n  }\n}\n\nexport { AnimationDriver, NoopAnimationDriver, Animation as ɵAnimation, AnimationEngine as ɵAnimationEngine, AnimationRenderer as ɵAnimationRenderer, AnimationRendererFactory as ɵAnimationRendererFactory, AnimationStyleNormalizer as ɵAnimationStyleNormalizer, BaseAnimationRenderer as ɵBaseAnimationRenderer, ENTER_CLASSNAME as ɵENTER_CLASSNAME, LEAVE_CLASSNAME as ɵLEAVE_CLASSNAME, NoopAnimationStyleNormalizer as ɵNoopAnimationStyleNormalizer, TransitionAnimationPlayer as ɵTransitionAnimationPlayer, WebAnimationsDriver as ɵWebAnimationsDriver, WebAnimationsPlayer as ɵWebAnimationsPlayer, WebAnimationsStyleNormalizer as ɵWebAnimationsStyleNormalizer, allowPreviousPlayerStylesMerge as ɵallowPreviousPlayerStylesMerge, camelCaseToDashCase as ɵcamelCaseToDashCase, containsElement as ɵcontainsElement, createEngine as ɵcreateEngine, getParentElement as ɵgetParentElement, invokeQuery as ɵinvokeQuery, normalizeKeyframes$1 as ɵnormalizeKeyframes, validateStyleProperty as ɵvalidateStyleProperty, validateWebAnimatableStyleProperty as ɵvalidateWebAnimatableStyleProperty };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}